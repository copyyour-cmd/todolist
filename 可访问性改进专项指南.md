# ♿ TodoList 可访问性改进专项指南

**目标**: 符合 WCAG 2.1 AA 标准,支持所有用户群体

**当前评分**: 6.5/10 ⚠️
**目标评分**: 9.0/10 ✅

---

## 📊 WCAG 2.1 AA 合规性检查

### 当前状况

| 指标 | 当前状态 | WCAG要求 | 合规性 |
|-----|---------|---------|--------|
| 颜色对比度 | 未验证 | ≥4.5:1 | ⚠️ 未知 |
| 屏幕阅读器 | 部分支持 | 完整语义 | ❌ 不合规 |
| 字体缩放 | 固定大小 | 支持200% | ❌ 不合规 |
| 键盘导航 | 有限支持 | 完全支持 | ⚠️ 部分合规 |
| 触摸区域 | 部分过小 | ≥44x44px | ⚠️ 部分合规 |
| 焦点指示器 | 默认样式 | 清晰可见 | ⚠️ 可改进 |

---

## 🎯 改进优先级

### Phase 1: 关键合规性 (2周)

#### 1.1 颜色对比度验证和修复 ⚠️ P0

**WCAG 标准**:
- 正常文字 (< 18px): **4.5:1**
- 大文字 (≥ 18px 或 ≥ 14px 加粗): **3:1**
- 图形元素和 UI 组件: **3:1**

**实施步骤**:

**第1步: 创建对比度检查工具**

```dart
// lib/src/core/accessibility/contrast_checker.dart

import 'dart:math';
import 'package:flutter/material.dart';

class ContrastChecker {
  /// 检查颜色对比度是否符合 WCAG 2.1 AA 标准
  ///
  /// [foreground] 前景色 (文字/图标)
  /// [background] 背景色
  /// [isLargeText] 是否为大文字 (≥18px 或 ≥14px bold)
  /// 返回: true 表示符合标准
  static bool meetsWCAG_AA(
    Color foreground,
    Color background, {
    bool isLargeText = false,
  }) {
    final ratio = calculateContrast(foreground, background);
    final threshold = isLargeText ? 3.0 : 4.5;
    return ratio >= threshold;
  }

  /// 检查是否符合 WCAG 2.1 AAA 标准 (更严格)
  static bool meetsWCAG_AAA(
    Color foreground,
    Color background, {
    bool isLargeText = false,
  }) {
    final ratio = calculateContrast(foreground, background);
    final threshold = isLargeText ? 4.5 : 7.0;
    return ratio >= threshold;
  }

  /// 计算对比度比率
  ///
  /// 返回: 对比度比率 (1.0 - 21.0)
  static double calculateContrast(Color color1, Color color2) {
    final luminance1 = _relativeLuminance(color1);
    final luminance2 = _relativeLuminance(color2);

    final lighter = max(luminance1, luminance2);
    final darker = min(luminance1, luminance2);

    return (lighter + 0.05) / (darker + 0.05);
  }

  /// 计算相对亮度
  ///
  /// 使用 sRGB 色彩空间的相对亮度公式
  /// 参考: https://www.w3.org/WAI/GL/wiki/Relative_luminance
  static double _relativeLuminance(Color color) {
    final r = _channelLuminance(color.red);
    final g = _channelLuminance(color.green);
    final b = _channelLuminance(color.blue);

    // 加权求和 (人眼对绿色最敏感)
    return 0.2126 * r + 0.7152 * g + 0.0722 * b;
  }

  /// 计算单通道亮度
  static double _channelLuminance(int channelValue) {
    final c = channelValue / 255.0;

    // gamma 校正
    if (c <= 0.03928) {
      return c / 12.92;
    } else {
      return pow((c + 0.055) / 1.055, 2.4).toDouble();
    }
  }

  /// 获取对比度评级
  static ContrastRating getRating(double ratio, {bool isLargeText = false}) {
    if (isLargeText) {
      if (ratio >= 7.0) return ContrastRating.aaaPass;
      if (ratio >= 4.5) return ContrastRating.aaPass;
      if (ratio >= 3.0) return ContrastRating.aaLargePass;
      return ContrastRating.fail;
    } else {
      if (ratio >= 7.0) return ContrastRating.aaaPass;
      if (ratio >= 4.5) return ContrastRating.aaPass;
      return ContrastRating.fail;
    }
  }

  /// 建议改进颜色以达到目标对比度
  static Color suggestForegroundColor(
    Color background,
    double targetRatio, {
    bool preferDark = true,
  }) {
    // 简化实现: 返回黑色或白色
    final contrastWithBlack = calculateContrast(Colors.black, background);
    final contrastWithWhite = calculateContrast(Colors.white, background);

    if (preferDark && contrastWithBlack >= targetRatio) {
      return Colors.black;
    } else if (contrastWithWhite >= targetRatio) {
      return Colors.white;
    } else {
      // 返回对比度更高的颜色
      return contrastWithBlack > contrastWithWhite
          ? Colors.black
          : Colors.white;
    }
  }
}

enum ContrastRating {
  fail,           // 不符合任何标准
  aaLargePass,    // 仅符合 AA 大文字标准
  aaPass,         // 符合 AA 标准
  aaaPass,        // 符合 AAA 标准
}

extension ContrastRatingExtension on ContrastRating {
  String get description {
    switch (this) {
      case ContrastRating.fail:
        return '不符合 WCAG 标准';
      case ContrastRating.aaLargePass:
        return 'WCAG AA (仅大文字)';
      case ContrastRating.aaPass:
        return 'WCAG AA ✓';
      case ContrastRating.aaaPass:
        return 'WCAG AAA ✓✓';
    }
  }

  Color get statusColor {
    switch (this) {
      case ContrastRating.fail:
        return Colors.red;
      case ContrastRating.aaLargePass:
        return Colors.orange;
      case ContrastRating.aaPass:
        return Colors.green;
      case ContrastRating.aaaPass:
        return Colors.blue;
    }
  }
}
```

**第2步: 在主题中验证所有配色**

```dart
// lib/src/app/theme/app_theme.dart

import 'package:todolist/src/core/accessibility/contrast_checker.dart';

class AppTheme {
  static ThemeData light([...]) {
    final theme = FlexThemeData.light(...);

    // 开发模式下验证对比度
    assert(() {
      _validateColorContrast(theme.colorScheme);
      return true;
    }());

    return theme;
  }

  /// 验证主题配色对比度
  static void _validateColorContrast(ColorScheme scheme) {
    final checks = [
      // 基础表面
      _ContrastCheck(
        name: 'Surface text',
        foreground: scheme.onSurface,
        background: scheme.surface,
        isLargeText: false,
      ),
      _ContrastCheck(
        name: 'Surface variant text',
        foreground: scheme.onSurfaceVariant,
        background: scheme.surface,
        isLargeText: false,
      ),

      // 主色
      _ContrastCheck(
        name: 'Primary button',
        foreground: scheme.onPrimary,
        background: scheme.primary,
        isLargeText: false,
      ),
      _ContrastCheck(
        name: 'Primary container',
        foreground: scheme.onPrimaryContainer,
        background: scheme.primaryContainer,
        isLargeText: false,
      ),

      // 错误色
      _ContrastCheck(
        name: 'Error',
        foreground: scheme.onError,
        background: scheme.error,
        isLargeText: false,
      ),

      // 卡片
      _ContrastCheck(
        name: 'Card text',
        foreground: scheme.onSurface,
        background: scheme.surfaceContainerLow,
        isLargeText: false,
      ),
    ];

    final failures = <String>[];

    for (final check in checks) {
      final ratio = ContrastChecker.calculateContrast(
        check.foreground,
        check.background,
      );

      if (!ContrastChecker.meetsWCAG_AA(
        check.foreground,
        check.background,
        isLargeText: check.isLargeText,
      )) {
        failures.add(
          '${check.name}: ${ratio.toStringAsFixed(2)}:1 '
          '(需要 ${check.isLargeText ? "3.0" : "4.5"}:1)',
        );
      }
    }

    if (failures.isNotEmpty) {
      debugPrint('⚠️ WCAG 对比度检查失败:');
      for (final failure in failures) {
        debugPrint('  - $failure');
      }

      throw FlutterError(
        '主题配色不符合 WCAG 2.1 AA 标准:\n${failures.join("\n")}',
      );
    }

    debugPrint('✅ WCAG 对比度检查通过');
  }
}

class _ContrastCheck {
  final String name;
  final Color foreground;
  final Color background;
  final bool isLargeText;

  _ContrastCheck({
    required this.name,
    required this.foreground,
    required this.background,
    required this.isLargeText,
  });
}
```

**第3步: 修复不符合标准的颜色**

```dart
// 检查当前使用的颜色
final problematicColors = [
  // 次要文字色
  Color(0xFF757575), // 在白色背景上对比度约 4.6:1 ✓ (刚好合格)

  // 边框色
  Color(0xFFE0E0E0), // 在白色背景上对比度约 1.3:1 ❌ (不合格,但边框不强制要求)

  // 优先级点
  Colors.blue.shade600,   // 需要验证
  Colors.orange.shade600, // 需要验证
  Colors.red.shade700,    // 需要验证
];

// 如果不合格,调整颜色
// 方法1: 加深颜色
final adjustedColor = Color.lerp(originalColor, Colors.black, 0.2);

// 方法2: 使用工具建议的颜色
final suggestedColor = ContrastChecker.suggestForegroundColor(
  backgroundColor,
  4.5, // 目标对比度
  preferDark: true,
);
```

**工作量**: 8 小时

---

#### 1.2 屏幕阅读器完整支持 ⚠️ P0

**目标**: 所有交互元素都有清晰的语义信息

**实施步骤**:

**第1步: 为任务卡片添加完整语义**

```dart
// lib/src/features/home/presentation/widgets/accessible_task_card.dart

class AccessibleTaskCard extends StatelessWidget {
  final Task task;

  @override
  Widget build(BuildContext context) {
    return Semantics(
      // 主标签: 完整描述任务信息
      label: _buildSemanticLabel(),

      // 提示: 告诉用户可以做什么
      hint: _buildSemanticHint(),

      // 语义角色
      button: true,
      enabled: true,

      // 点击动作
      onTap: () => _editTask(),

      // 长按动作
      onLongPress: () => _showContextMenu(),

      child: Card(
        child: InkWell(
          onTap: _editTask,
          onLongPress: _showContextMenu,
          child: Padding(
            padding: EdgeInsets.all(16),
            child: Row(
              children: [
                // 优先级指示器 - 排除在语义树外 (已在 label 中描述)
                ExcludeSemantics(
                  child: _PriorityDot(priority: task.priority),
                ),

                SizedBox(width: 12),

                // 任务内容
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      // 标题 - 合并到父级 Semantics
                      Text(task.title),

                      if (task.notes != null) ...[
                        SizedBox(height: 4),
                        // 备注 - 自动包含在语义中
                        Text(
                          task.notes!,
                          style: TextStyle(color: Colors.grey[600]),
                        ),
                      ],

                      if (task.dueAt != null) ...[
                        SizedBox(height: 8),
                        // 截止时间 - 添加语义标签
                        Semantics(
                          label: _formatDueAtForScreenReader(task.dueAt!),
                          excludeSemantics: true,
                          child: Row(
                            children: [
                              Icon(Icons.timer_outlined, size: 16),
                              SizedBox(width: 4),
                              Text(_formatDueAt(task.dueAt!)),
                            ],
                          ),
                        ),
                      ],
                    ],
                  ),
                ),

                // 完成复选框 - 独立语义
                Semantics(
                  label: task.isCompleted ? '已完成' : '未完成',
                  hint: task.isCompleted ? '双击标记为未完成' : '双击标记为完成',
                  checked: task.isCompleted,
                  child: Checkbox(
                    value: task.isCompleted,
                    onChanged: (value) => _toggleCompletion(value!),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  String _buildSemanticLabel() {
    final parts = <String>[];

    // 1. 优先级
    final priority = _getPriorityLabel(task.priority);
    if (priority != '无') {
      parts.add('$priority优先级');
    }

    // 2. 任务标题
    parts.add('任务');
    parts.add(task.title);

    // 3. 完成状态
    if (task.isCompleted) {
      parts.add('已完成');
    }

    // 4. 截止时间 (如果有)
    if (task.dueAt != null) {
      parts.add(_formatDueAtForScreenReader(task.dueAt!));
    }

    // 5. 子任务进度 (如果有)
    if (task.subtasks.isNotEmpty) {
      final completed = task.subtasks.where((s) => s.isCompleted).length;
      final total = task.subtasks.length;
      parts.add('$completed/$total 个子任务已完成');
    }

    return parts.join(', ');
  }

  String _buildSemanticHint() {
    return '双击编辑任务, 长按显示更多选项';
  }

  String _getPriorityLabel(TaskPriority priority) {
    return switch (priority) {
      TaskPriority.none => '无',
      TaskPriority.low => '低',
      TaskPriority.medium => '中',
      TaskPriority.high => '高',
      TaskPriority.critical => '紧急',
    };
  }

  String _formatDueAtForScreenReader(DateTime dueAt) {
    final now = DateTime.now();
    final diff = dueAt.difference(now);

    if (diff.inDays == 0) {
      if (diff.isNegative) {
        return '已逾期 ${diff.abs().inHours} 小时';
      } else {
        return '今天 ${DateFormat('HH:mm').format(dueAt)} 到期';
      }
    } else if (diff.inDays == 1) {
      return '明天到期';
    } else if (diff.inDays > 0 && diff.inDays <= 7) {
      return '${diff.inDays} 天后到期';
    } else {
      return '${DateFormat('yyyy年M月d日').format(dueAt)} 到期';
    }
  }

  Future<void> _toggleCompletion(bool value) async {
    // 通知屏幕阅读器状态变化
    SemanticsService.announce(
      value ? '任务已完成' : '任务已取消完成',
      TextDirection.ltr,
    );

    // 触觉反馈
    if (value) {
      HapticFeedbackHelper.success();
    } else {
      HapticFeedbackHelper.light();
    }

    // 执行切换
    await taskService.toggleCompletion(task, isCompleted: value);
  }
}
```

**第2步: 为统计卡片添加语义**

```dart
// Dashboard 统计卡片
Semantics(
  label: '今日完成',
  value: '$completed / $total 个任务',
  hint: '双击查看今日任务',
  button: true,
  onTap: () => _showTodayTasks(),
  child: DashboardCard(...),
)

// 进度条
Semantics(
  label: '子任务进度',
  value: '${(progress * 100).toInt()}%',
  child: LinearProgressIndicator(value: progress),
)
```

**第3步: 为筛选器添加语义**

```dart
// 快速筛选 Chip
Semantics(
  label: '筛选',
  value: isSelected ? '已选择 今天' : '今天',
  hint: '双击筛选今天的任务',
  button: true,
  selected: isSelected,
  onTap: () {
    // 通知屏幕阅读器
    SemanticsService.announce(
      '已筛选今天的任务',
      TextDirection.ltr,
    );
    _applyFilter();
  },
  child: FilterChip(...),
)
```

**需要添加语义的所有组件**:

- ✅ 任务卡片 (优先级 + 标题 + 状态 + 截止时间)
- ✅ 复选框 (完成/未完成 + 提示)
- ✅ 日期时间 (格式化朗读)
- ✅ 进度条 (百分比)
- ✅ 筛选器 (当前状态 + 提示)
- ✅ 统计卡片 (数值 + 单位)
- ✅ 按钮 (功能描述)
- ✅ 对话框 (标题 + 内容摘要)

**工作量**: 12 小时

---

#### 1.3 动态内容通知 ⚠️ P0

**使用 SemanticsService.announce 通知用户重要变化**:

```dart
// 任务完成
await toggleCompletion();
SemanticsService.announce(
  '任务"${task.title}"已完成',
  TextDirection.ltr,
);

// 任务删除
await deleteTask();
SemanticsService.announce(
  '已删除任务"${task.title}"',
  TextDirection.ltr,
);

// 筛选变更
applyFilter(filter);
SemanticsService.announce(
  '已筛选 ${filter.name},找到 $count 个任务',
  TextDirection.ltr,
);

// 错误发生
try {
  await saveTask();
} catch (e) {
  SemanticsService.announce(
    '保存失败: $e',
    TextDirection.ltr,
  );
}
```

**工作量**: 3 小时

---

### Phase 2: 用户体验增强 (1周)

#### 2.1 字体大小可调节 ⚠️ P1

**实施方案**:

```dart
// 1. 定义字体缩放选项
enum TextScaleOption {
  system,     // 跟随系统 (推荐)
  small,      // 0.85x
  medium,     // 1.0x (默认)
  large,      // 1.15x
  extraLarge, // 1.3x
}

// 2. 在 AppSettings 中保存用户选择
class AppSettings {
  final TextScaleOption textScale;
  // ...
}

// 3. 在设置页添加选择器
class TextScaleSelector extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final settings = ref.watch(appSettingsProvider);
    final currentScale = settings.valueOrNull?.textScale ?? TextScaleOption.system;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text('字体大小', style: theme.textTheme.titleMedium),
        SizedBox(height: 12),

        SegmentedButton<TextScaleOption>(
          segments: [
            ButtonSegment(
              value: TextScaleOption.system,
              label: Text('跟随系统'),
              icon: Icon(Icons.smartphone),
            ),
            ButtonSegment(
              value: TextScaleOption.small,
              label: Text('小'),
            ),
            ButtonSegment(
              value: TextScaleOption.medium,
              label: Text('标准'),
            ),
            ButtonSegment(
              value: TextScaleOption.large,
              label: Text('大'),
            ),
            ButtonSegment(
              value: TextScaleOption.extraLarge,
              label: Text('特大'),
            ),
          ],
          selected: {currentScale},
          onSelectionChanged: (Set<TextScaleOption> selected) {
            ref.read(appSettingsProvider.notifier).updateTextScale(
              selected.first,
            );
          },
        ),

        SizedBox(height: 16),

        // 预览
        Container(
          padding: EdgeInsets.all(16),
          decoration: BoxDecoration(
            color: theme.colorScheme.surfaceContainerLow,
            borderRadius: BorderRadius.circular(12),
          ),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                '预览',
                style: theme.textTheme.labelSmall,
              ),
              SizedBox(height: 8),
              Text(
                '这是正文文字的预览',
                style: theme.textTheme.bodyMedium,
              ),
              Text(
                '这是标题文字的预览',
                style: theme.textTheme.titleLarge,
              ),
            ],
          ),
        ),
      ],
    );
  }
}

// 4. 在 App 中应用字体缩放
class App extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final settings = ref.watch(appSettingsProvider).valueOrNull;
    final textScale = settings?.textScale ?? TextScaleOption.system;

    return MaterialApp.router(
      builder: (context, child) {
        final mediaQueryData = MediaQuery.of(context);
        final scaleFactor = _getScaleFactor(textScale, mediaQueryData.textScaleFactor);

        return MediaQuery(
          data: mediaQueryData.copyWith(
            textScaleFactor: scaleFactor,
          ),
          child: child!,
        );
      },
      // ...
    );
  }

  double _getScaleFactor(TextScaleOption option, double systemScale) {
    return switch (option) {
      TextScaleOption.system => systemScale,
      TextScaleOption.small => 0.85,
      TextScaleOption.medium => 1.0,
      TextScaleOption.large => 1.15,
      TextScaleOption.extraLarge => 1.3,
    };
  }
}
```

**测试**: 确保所有文字在 200% 缩放下仍可读且不溢出

**工作量**: 6 小时

---

#### 2.2 焦点管理和键盘导航 ⚠️ P1

**目标**: 所有操作都可以通过键盘完成

**实施方案**:

```dart
// lib/src/core/accessibility/keyboard_shortcuts.dart

class AppShortcuts {
  // 任务操作
  static const toggleCompletion = SingleActivator(LogicalKeyboardKey.space);
  static const editTask = SingleActivator(LogicalKeyboardKey.enter);
  static const deleteTask = SingleActivator(LogicalKeyboardKey.delete);

  // 导航
  static const nextTask = SingleActivator(LogicalKeyboardKey.arrowDown);
  static const previousTask = SingleActivator(LogicalKeyboardKey.arrowUp);
  static const firstTask = SingleActivator(LogicalKeyboardKey.home);
  static const lastTask = SingleActivator(LogicalKeyboardKey.end);

  // 筛选
  static const showAllTasks = SingleActivator(
    LogicalKeyboardKey.digit1,
    meta: true, // Cmd/Ctrl + 1
  );
  static const showTodayTasks = SingleActivator(
    LogicalKeyboardKey.digit2,
    meta: true,
  );

  // 创建
  static const newTask = SingleActivator(
    LogicalKeyboardKey.keyN,
    meta: true,
  );
}

// 在任务卡片中实现
class FocusableTaskCard extends StatefulWidget {
  final Task task;

  @override
  Widget build(BuildContext context) {
    return Focus(
      onKey: (node, event) {
        if (event is RawKeyDownEvent) {
          if (event.logicalKey == LogicalKeyboardKey.space) {
            _toggleCompletion();
            return KeyEventResult.handled;
          } else if (event.logicalKey == LogicalKeyboardKey.enter) {
            _editTask();
            return KeyEventResult.handled;
          } else if (event.logicalKey == LogicalKeyboardKey.delete) {
            _deleteTask();
            return KeyEventResult.handled;
          }
        }
        return KeyEventResult.ignored;
      },
      child: FocusableActionDetector(
        onShowFocusHighlight: (hasFocus) {
          setState(() => _hasFocus = hasFocus);
        },
        onShowHoverHighlight: (hasHover) {
          setState(() => _hasHover = hasHover);
        },
        child: Container(
          decoration: BoxDecoration(
            border: Border.all(
              color: _hasFocus
                  ? theme.colorScheme.primary
                  : (_hasHover ? theme.colorScheme.outline : Colors.transparent),
              width: _hasFocus ? 2 : 1,
            ),
            borderRadius: BorderRadius.circular(20),
          ),
          child: TaskCard(task: task),
        ),
      ),
    );
  }
}

// 设置 Tab 顺序
FocusTraversalGroup(
  policy: OrderedTraversalPolicy(),
  child: Column(
    children: tasks.asMap().entries.map((entry) {
      return FocusTraversalOrder(
        order: NumericFocusOrder(entry.key.toDouble()),
        child: FocusableTaskCard(task: entry.value),
      );
    }).toList(),
  ),
)
```

**工作量**: 8 小时

---

#### 2.3 触摸区域大小检查 ⚠️ P2

**WCAG 要求**: 最小 44x44 像素

**检查和修复**:

```dart
// ❌ 可能过小的元素
IconButton(
  icon: Icon(Icons.timer, size: 20),
  visualDensity: VisualDensity.compact, // 可能导致区域 < 44px
)

// ✅ 确保最小尺寸
IconButton(
  icon: Icon(Icons.timer, size: 20),
  constraints: BoxConstraints(
    minWidth: 44,
    minHeight: 44,
  ),
  padding: EdgeInsets.all(12),
)

// 或使用包装器
class MinTouchTarget extends StatelessWidget {
  final Widget child;

  @override
  Widget build(BuildContext context) {
    return ConstrainedBox(
      constraints: BoxConstraints(
        minWidth: 44,
        minHeight: 44,
      ),
      child: child,
    );
  }
}
```

**工作量**: 4 小时

---

## 🧪 测试计划

### 自动化测试

```dart
// test/accessibility/contrast_test.dart

void main() {
  group('Contrast Checker', () {
    test('Black on white meets AA', () {
      expect(
        ContrastChecker.meetsWCAG_AA(Colors.black, Colors.white),
        true,
      );
    });

    test('Grey on white fails AA for small text', () {
      expect(
        ContrastChecker.meetsWCAG_AA(
          Colors.grey[400]!,
          Colors.white,
        ),
        false,
      );
    });

    test('Theme colors meet AA', () {
      final theme = AppTheme.light();

      expect(
        ContrastChecker.meetsWCAG_AA(
          theme.colorScheme.onSurface,
          theme.colorScheme.surface,
        ),
        true,
      );
    });
  });
}
```

### 手动测试

#### 屏幕阅读器测试

**Android (TalkBack)**:
1. 设置 → 无障碍 → TalkBack → 开启
2. 滑动浏览任务列表
3. 验证朗读内容是否完整清晰
4. 双击执行操作
5. 检查操作结果通知

**iOS (VoiceOver)**:
1. 设置 → 辅助功能 → VoiceOver → 开启
2. 使用转子导航
3. 验证所有元素都可访问
4. 检查自定义手势

#### 字体缩放测试

1. 系统设置字体放大 200%
2. 检查所有页面布局
3. 确保文字不溢出
4. 确保可点击区域不重叠

#### 键盘导航测试

1. 连接外接键盘
2. 使用 Tab 键导航所有元素
3. 使用 Space/Enter 激活
4. 测试所有快捷键

---

## 📈 改进时间表

### 第1-2周: 关键合规性
- [ ] Day 1-2: 创建对比度检查工具 (4h)
- [ ] Day 3-4: 验证和修复主题配色 (4h)
- [ ] Day 5-8: 添加屏幕阅读器支持 (12h)
- [ ] Day 9-10: 动态内容通知 (3h)

**里程碑**: 可访问性评分 6.5 → 8.0

### 第3周: 用户体验增强
- [ ] Day 1-3: 字体大小可调节 (6h)
- [ ] Day 4-5: 焦点管理和键盘导航 (8h)
- [ ] Day 6: 触摸区域检查 (4h)

**里程碑**: 可访问性评分 8.0 → 9.0

---

## ✅ 验收标准

### WCAG 2.1 AA 合规性检查清单

- [ ] **1.4.3 对比度 (最小)**: 所有文字对比度 ≥ 4.5:1
- [ ] **1.4.4 文本缩放**: 支持 200% 缩放不影响功能
- [ ] **2.1.1 键盘**: 所有功能可用键盘操作
- [ ] **2.4.7 焦点可见**: 焦点指示器清晰可见
- [ ] **4.1.2 名称、角色、值**: 所有UI组件有正确语义
- [ ] **4.1.3 状态消息**: 状态变化及时通知用户

### 屏幕阅读器测试通过标准

- [ ] 任务信息完整朗读 (优先级+标题+状态+时间)
- [ ] 操作提示清晰 (双击编辑/长按菜单)
- [ ] 状态变化及时通知
- [ ] 导航顺序合理
- [ ] 无语义信息缺失
- [ ] 无冗余或混乱朗读

---

**更新日期**: 2025-10-20
**负责人**: 可访问性团队
**审核人**: UI/UX Lead
