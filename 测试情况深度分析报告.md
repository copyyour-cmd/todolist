# TodoListé¡¹ç›®æµ‹è¯•æ·±åº¦åˆ†ææŠ¥å‘Š

**åˆ†ææ—¥æœŸ**: 2025-10-20
**é¡¹ç›®ä½ç½®**: E:\todolist
**åˆ†æå¸ˆ**: Claude Code (Test Automation Engineer)

---

## ğŸ“Š ä¸€ã€æµ‹è¯•è¦†ç›–ç‡ç°çŠ¶

### 1.1 æ•´ä½“æ¦‚è§ˆ

| ç»´åº¦ | æ•°å€¼ | ç›®æ ‡ | å·®è· |
|------|------|------|------|
| æºä»£ç æ–‡ä»¶æ•° | 404ä¸ª | - | - |
| æµ‹è¯•æ–‡ä»¶æ•° | **4ä¸ª** | 80+ | âŒ 95%ç¼ºå¤± |
| å•å…ƒæµ‹è¯•è¦†ç›–ç‡ | <1% | 70% | âŒ æä½ |
| Widgetæµ‹è¯•è¦†ç›–ç‡ | <0.5% | 50% | âŒ æä½ |
| é›†æˆæµ‹è¯•è¦†ç›–ç‡ | 3% | 20% | âŒ æä½ |
| æ€»ä½“æµ‹è¯•è¦†ç›–ç‡ | <1% | 60% | ğŸ”´ **ä¸¥é‡ä¸è¶³** |

### 1.2 ç°æœ‰æµ‹è¯•æ–‡ä»¶è´¨é‡åˆ†æ

#### âœ… ä¼˜ç§€æµ‹è¯•: `note_link_integration_test.dart`

```
æµ‹è¯•æ•°é‡: 25ä¸ª (16ä¸ªåŠŸèƒ½ + 6ä¸ªè¾¹ç•Œ + 3ä¸ªç»¼åˆåœºæ™¯)
ä»£ç è¡Œæ•°: 334è¡Œ
è´¨é‡è¯„åˆ†: â­â­â­â­â­ 5/5
```

**äº®ç‚¹**:
- âœ… å®Œæ•´çš„æµ‹è¯•æµç¨‹è¦†ç›–
- âœ… ä½¿ç”¨Mockitoè¿›è¡Œä¾èµ–éš”ç¦»
- âœ… è¾¹ç•Œæ¡ä»¶å’Œå¼‚å¸¸æµ‹è¯•å®Œæ•´
- âœ… æµ‹è¯•å‘½åæ¸…æ™°ä¸”æœ‰ä¸­æ–‡æè¿°
- âœ… åŒ…å«å®Œæ•´ç”¨æˆ·æµç¨‹æµ‹è¯•

**ç¤ºä¾‹**:
```dart
test('16. å®Œæ•´æµç¨‹ï¼šåˆ›å»ºç¬”è®°ã€æ·»åŠ é“¾æ¥ã€è·å–åå‘é“¾æ¥', () async {
  // 1. ç”¨æˆ·åˆ›å»ºç¬”è®°Aå’Œç¬”è®°B
  when(mockRepository.getAll()).thenAnswer((_) async => [noteA, noteB]);

  // 2. ç”¨æˆ·åœ¨ç¬”è®°Bä¸­è¾“å…¥ [[ç¬”è®°A]]ï¼Œç³»ç»Ÿè‡ªåŠ¨æ›´æ–°é“¾æ¥
  final updatedNoteB = await linkService.updateNoteLinks(noteB);

  // 3. ç”¨æˆ·æŸ¥çœ‹ç¬”è®°Aï¼Œåº”è¯¥èƒ½çœ‹åˆ°ç¬”è®°Båœ¨åå‘é“¾æ¥ä¸­
  final stats = await linkService.getLinkStats('note-a');
  expect(stats.hasLinks, true);
});
```

#### âš ï¸ éœ€æ”¹è¿›: `widget_test.dart`

```
æµ‹è¯•æ•°é‡: 1ä¸ª
ä»£ç è¡Œæ•°: 36è¡Œ
è´¨é‡è¯„åˆ†: â­â­ 2/5
```

**é—®é¢˜**:
- âŒ **æµ‹è¯•å¤±è´¥**: Hiveæœªåˆå§‹åŒ–å¯¼è‡´HiveError
- âŒ ä»…æµ‹è¯•ä¸€ä¸ªç©ºçŠ¶æ€åœºæ™¯
- âŒ æ²¡æœ‰Mock Providerä¾èµ–
- âŒ è¦†ç›–ç‡æä½

**é”™è¯¯ä¿¡æ¯**:
```
HiveError: You need to initialize Hive or provide a path to store the box.
Expected: exactly one matching candidate
Actual: _TextWidgetFinder:<Found 0 widgets with text "Nothing planned yet": []>
```

#### âœ… è‰¯å¥½æµ‹è¯•: `task_serialization_test.dart`

```
æµ‹è¯•æ•°é‡: 3ä¸ª
ä»£ç è¡Œæ•°: 83è¡Œ
è´¨é‡è¯„åˆ†: â­â­â­â­ 4/5
```

**ä¼˜ç‚¹**:
- âœ… æµ‹è¯•å®ä½“åºåˆ—åŒ–æ­£ç¡®æ€§
- âœ… éªŒè¯JSONå¾€è¿”è½¬æ¢
- âœ… åŒ…å«å¤æ‚åµŒå¥—å¯¹è±¡

**ä¸è¶³**:
- âš ï¸ ä»…è¦†ç›–3ä¸ªå®ä½“(Task/TaskList/Tag)
- âš ï¸ ç¼ºå°‘å…¶ä»–26ä¸ªå®ä½“çš„æµ‹è¯•

---

## ğŸ¯ äºŒã€æµ‹è¯•è´¨é‡æ·±åº¦è¯„ä¼°

### 2.1 æŒ‰åŠŸèƒ½æ¨¡å—åˆ†æ

#### ğŸ“‹ ä»»åŠ¡ç®¡ç†æ¨¡å— (0%è¦†ç›–)

**æ ¸å¿ƒæœåŠ¡**: `task_service.dart`
**ä»£ç è¡Œæ•°**: 332è¡Œ
**å¤æ‚åº¦**: ğŸ”´ é«˜
**æµ‹è¯•è¦†ç›–**: âŒ 0%

**å…³é”®ä¸šåŠ¡é€»è¾‘**:
1. **ä»»åŠ¡åˆ›å»º** (`createTask`) - å¤æ‚åº¦é«˜
   - æ™ºèƒ½æé†’åˆ›å»ºå’Œå…³è”
   - é‡å¤ä»»åŠ¡å¤„ç†
   - é€šçŸ¥åŒæ­¥
   - æ¸¸æˆåŒ–ç³»ç»Ÿè§¦å‘

2. **ä»»åŠ¡æ›´æ–°** (`updateTask`) - å¤æ‚åº¦é«˜
   - æ™ºèƒ½æé†’æ›´æ–°é€»è¾‘
   - ç‰ˆæœ¬æ§åˆ¶
   - çº§è”æ›´æ–°

3. **ä»»åŠ¡å®Œæˆåˆ‡æ¢** (`toggleCompletion`) - å¤æ‚åº¦ä¸­
   - çŠ¶æ€å˜æ›´
   - æ¸¸æˆåŒ–è§¦å‘
   - é‡å¤ä»»åŠ¡ä¸‹ä¸€æ¬¡ç”Ÿæˆ

4. **å­ä»»åŠ¡åˆ‡æ¢** (`toggleSubTask`) - å¤æ‚åº¦ä¸­
   - å­ä»»åŠ¡çŠ¶æ€æ›´æ–°
   - çˆ¶ä»»åŠ¡ç‰ˆæœ¬æ›´æ–°

**ç¼ºå¤±æµ‹è¯•åœºæ™¯**:
```dart
// åº”è¯¥æœ‰çš„æµ‹è¯•ç”¨ä¾‹:
test('åˆ›å»ºä»»åŠ¡æ—¶åº”è¯¥ç”Ÿæˆå”¯ä¸€ID')
test('åˆ›å»ºä»»åŠ¡æ—¶åº”è¯¥è®¾ç½®æ­£ç¡®çš„åˆ›å»ºæ—¶é—´')
test('åˆ›å»ºé‡å¤ä»»åŠ¡æ—¶åº”è¯¥è®¾ç½®parentRecurringTaskId')
test('åˆ›å»ºä»»åŠ¡æ—¶æ™ºèƒ½æé†’å¤±è´¥ä¸åº”å½±å“ä»»åŠ¡åˆ›å»º')
test('æ›´æ–°ä»»åŠ¡æ—¶åº”è¯¥åˆ é™¤æ—§çš„æ™ºèƒ½æé†’')
test('æ›´æ–°ä»»åŠ¡æ—¶åº”è¯¥å¢åŠ ç‰ˆæœ¬å·')
test('å®Œæˆä»»åŠ¡æ—¶åº”è¯¥è§¦å‘æ¸¸æˆåŒ–ç³»ç»Ÿ')
test('å®Œæˆé‡å¤ä»»åŠ¡æ—¶åº”è¯¥ç”Ÿæˆä¸‹ä¸€æ¬¡ä»»åŠ¡')
test('åˆ é™¤ä»»åŠ¡æ—¶åº”è¯¥æ¸…ç†æ‰€æœ‰æ™ºèƒ½æé†’')
test('åˆ é™¤ä»»åŠ¡æ—¶åº”è¯¥å–æ¶ˆé€šçŸ¥')
```

#### ğŸ” é‡å¤ä»»åŠ¡æ¨¡å— (0%è¦†ç›–)

**æ ¸å¿ƒæœåŠ¡**: `recurrence_service.dart`
**ä»£ç è¡Œæ•°**: 139è¡Œ
**å¤æ‚åº¦**: ğŸ”´ é«˜ (ç®—æ³•é€»è¾‘å¤æ‚)
**æµ‹è¯•è¦†ç›–**: âŒ 0%

**å…³é”®ç®—æ³•**:
1. **ä¸‹ä¸€æ¬¡ä»»åŠ¡ç”Ÿæˆ** (`handleRecurringTaskCompletion`)
   - è®¡ç®—ä¸‹æ¬¡åˆ°æœŸæ—¥æœŸ
   - æé†’æ—¶é—´åç§»è®¡ç®—
   - é‡å¤æ¬¡æ•°æ§åˆ¶
   - ç»“æŸæ¡ä»¶åˆ¤æ–­

2. **é‡å¤ä»»åŠ¡ç³»åˆ—ç®¡ç†**
   - æ‰¹é‡æ›´æ–°æœªæ¥ä»»åŠ¡
   - åˆ é™¤æœªæ¥ä»»åŠ¡ç³»åˆ—

**ç¼ºå¤±æµ‹è¯•åœºæ™¯**:
```dart
// æ¯æ—¥é‡å¤
test('æ¯æ—¥é‡å¤ä»»åŠ¡å®Œæˆååº”è¯¥ç”Ÿæˆæ˜å¤©çš„ä»»åŠ¡')
test('æ¯æ—¥é‡å¤ä»»åŠ¡åˆ°è¾¾æœ€å¤§æ¬¡æ•°åä¸åº”ç”Ÿæˆæ–°ä»»åŠ¡')

// æ¯å‘¨é‡å¤
test('æ¯å‘¨é‡å¤ä»»åŠ¡åº”è¯¥åœ¨ä¸‹å‘¨åŒä¸€å¤©ç”Ÿæˆ')
test('æ¯å‘¨å¤šå¤©é‡å¤ä»»åŠ¡åº”è¯¥æ­£ç¡®è®¡ç®—ä¸‹æ¬¡æ—¥æœŸ')

// æ¯æœˆé‡å¤
test('æ¯æœˆé‡å¤ä»»åŠ¡åº”è¯¥åœ¨ä¸‹æœˆåŒä¸€æ—¥ç”Ÿæˆ')
test('æ¯æœˆ31æ—¥é‡å¤åœ¨å°æœˆåº”è¯¥è°ƒæ•´ä¸ºæœ€åä¸€å¤©')

// è¾¹ç•Œæ¡ä»¶
test('æé†’æ—¶é—´åº”è¯¥ä¿æŒä¸åˆ°æœŸæ—¶é—´çš„åç§»')
test('å·²å®Œæˆçš„ä»»åŠ¡ä¸åº”ç”Ÿæˆä¸‹ä¸€æ¬¡ä»»åŠ¡')
test('é‡å¤è§„åˆ™ä¸ºç©ºæ—¶ä¸åº”ç”Ÿæˆä»»åŠ¡')
test('æ›´æ–°é‡å¤ä»»åŠ¡ç³»åˆ—åº”è¯¥åº”ç”¨åˆ°æ‰€æœ‰æœªæ¥ä»»åŠ¡')
```

#### ğŸ’¾ æ•°æ®æŒä¹…åŒ–æ¨¡å— (2%è¦†ç›–)

**æ ¸å¿ƒRepository**: `hive_task_repository.dart`
**ä»£ç è¡Œæ•°**: 311è¡Œ
**å¤æ‚åº¦**: ğŸ”´ é«˜ (æ€§èƒ½ä¼˜åŒ–å¤æ‚)
**æµ‹è¯•è¦†ç›–**: âŒ 0%

**æ€§èƒ½ä¼˜åŒ–ç‰¹æ€§**:
1. **æ™ºèƒ½ç¼“å­˜ç³»ç»Ÿ**
   - ç¼“å­˜å·²æ’åºä»»åŠ¡åˆ—è¡¨
   - å¢é‡æ›´æ–°ç­–ç•¥
   - äºŒåˆ†æ’å…¥ç®—æ³•
   - ç¼“å­˜å¤±æ•ˆæ£€æµ‹

2. **æ€§èƒ½ç›‘æ§**
   - ç¼“å­˜å‘½ä¸­ç‡ç»Ÿè®¡
   - å¢é‡æ›´æ–°è®¡æ•°
   - å…¨é‡æ’åºè®¡æ•°

**ç¼ºå¤±æµ‹è¯•åœºæ™¯**:
```dart
// åŸºç¡€CRUD
test('ä¿å­˜ä»»åŠ¡åº”è¯¥æˆåŠŸå­˜å‚¨åˆ°æ•°æ®åº“')
test('è·å–ä»»åŠ¡åº”è¯¥è¿”å›æ­£ç¡®çš„ä»»åŠ¡å¯¹è±¡')
test('åˆ é™¤ä»»åŠ¡åº”è¯¥ä»æ•°æ®åº“ç§»é™¤')
test('æ‰¹é‡ä¿å­˜åº”è¯¥ä¸€æ¬¡æ€§ä¿å­˜å¤šä¸ªä»»åŠ¡')

// ç¼“å­˜æ€§èƒ½
test('é¦–æ¬¡è·å–ä»»åŠ¡åº”è¯¥ç¼“å­˜ç»“æœ')
test('åç»­è·å–ä»»åŠ¡åº”è¯¥ä½¿ç”¨ç¼“å­˜')
test('å•ä¸ªä»»åŠ¡å˜æ›´åº”è¯¥ä½¿ç”¨å¢é‡æ›´æ–°')
test('æ‰¹é‡å˜æ›´åº”è¯¥è§¦å‘å…¨é‡é‡æ’')
test('äºŒåˆ†æ’å…¥åº”è¯¥ä¿æŒåˆ—è¡¨æœ‰åº')

// æŸ¥è¯¢åŠŸèƒ½
test('æŒ‰æ—¥æœŸèŒƒå›´æŸ¥è¯¢åº”è¯¥è¿”å›æ­£ç¡®ä»»åŠ¡')
test('watchAllåº”è¯¥ç›‘å¬ä»»åŠ¡å˜åŒ–')
test('watchByIdåº”è¯¥ç›‘å¬å•ä¸ªä»»åŠ¡å˜åŒ–')

// æ€§èƒ½ç»Ÿè®¡
test('ç¼“å­˜å‘½ä¸­ç‡åº”è¯¥æ­£ç¡®è®¡ç®—')
test('æ€§èƒ½ç»Ÿè®¡åº”è¯¥æ­£ç¡®è®°å½•å„é¡¹æŒ‡æ ‡')
```

#### â˜ï¸ äº‘åŒæ­¥æ¨¡å— (0%è¦†ç›–)

**å…³é”®åŠŸèƒ½**:
- å¢é‡åŒæ­¥
- å†²çªè§£å†³
- ç¦»çº¿é˜Ÿåˆ—
- æ–­ç‚¹ç»­ä¼ 

**æµ‹è¯•ç¼ºå¤±**: 100%

#### ğŸ® æ¸¸æˆåŒ–æ¨¡å— (0%è¦†ç›–)

**å…³é”®åŠŸèƒ½**:
- æˆå°±ç³»ç»Ÿ
- ç§¯åˆ†è®¡ç®—
- æ¯æ—¥ç­¾åˆ°
- æŒ‘æˆ˜ç³»ç»Ÿ

**æµ‹è¯•ç¼ºå¤±**: 100%

#### ğŸ“ ç¬”è®°é“¾æ¥æ¨¡å— (100%è¦†ç›–) âœ…

**å”¯ä¸€å®Œæ•´æµ‹è¯•çš„æ¨¡å—**
**æµ‹è¯•è´¨é‡**: ä¼˜ç§€
**å¯ä½œä¸ºå…¶ä»–æ¨¡å—æµ‹è¯•çš„èŒƒæœ¬**

---

## ğŸ› ï¸ ä¸‰ã€æµ‹è¯•ç­–ç•¥ä¸æ¶æ„è®¾è®¡

### 3.1 æµ‹è¯•é‡‘å­—å¡”æ¶æ„

```
å½“å‰çŠ¶æ€:              ç†æƒ³çŠ¶æ€:           æ”¹è¿›ç›®æ ‡:

    /\                    /\               /\
   /  \                  /  \ E2E 10%     / âœ“\ E2E 8%
  /    \                /____\           /____\
 /      \              /      \         /  âœ“  \
/        \            /        \       /________\ é›†æˆ 20%
/________\  0%       /          \     /          \
   æµ‹è¯•              /__________\ é›†æˆ/____________\ å•å…ƒ 70%
                    /            \   /              \
                   /______________\ /________________\
                      å•å…ƒ 70%          å½“å‰<1%

ç¬¬ä¸€é˜¶æ®µç›®æ ‡(4å‘¨):  å•å…ƒ30% + é›†æˆ5% + E2E0%
ç¬¬äºŒé˜¶æ®µç›®æ ‡(8å‘¨):  å•å…ƒ50% + é›†æˆ10% + E2E5%
ç¬¬ä¸‰é˜¶æ®µç›®æ ‡(12å‘¨): å•å…ƒ70% + é›†æˆ20% + E2E10%
```

### 3.2 TDDå®æ–½ç­–ç•¥

#### é˜¶æ®µ1: è¡¥å……ç°æœ‰ä»£ç æµ‹è¯• (ä¿®å¤æœŸ)

**ç›®æ ‡**: ä¸ºå·²æœ‰ä»£ç ç¼–å†™æµ‹è¯•ï¼Œå»ºç«‹æµ‹è¯•åŸºç¡€è®¾æ–½

**ä¼˜å…ˆçº§**:
1. ğŸ”´ **é«˜ä¼˜å…ˆçº§** (ç¬¬1-2å‘¨)
   - ä¿®å¤`widget_test.dart`
   - TaskServiceæ ¸å¿ƒé€»è¾‘
   - RecurrenceServiceç®—æ³•
   - Repository CRUDæ“ä½œ

2. ğŸŸ¡ **ä¸­ä¼˜å…ˆçº§** (ç¬¬3-4å‘¨)
   - äº‘åŒæ­¥æ ¸å¿ƒé€»è¾‘
   - æ™ºèƒ½æé†’æœåŠ¡
   - æ•°æ®åºåˆ—åŒ–
   - é€šçŸ¥æœåŠ¡

3. ğŸŸ¢ **ä½ä¼˜å…ˆçº§** (ç¬¬5-8å‘¨)
   - UI Widgetæµ‹è¯•
   - æ€§èƒ½æµ‹è¯•
   - é›†æˆæµ‹è¯•

#### é˜¶æ®µ2: TDDå¼€å‘æ–°åŠŸèƒ½ (è½¬å˜æœŸ)

**ç›®æ ‡**: æ‰€æœ‰æ–°åŠŸèƒ½é‡‡ç”¨TDDæ–¹å¼å¼€å‘

**æµç¨‹**:
```dart
// 1. ç¼–å†™å¤±è´¥æµ‹è¯• (Red)
test('æ–°åŠŸèƒ½åº”è¯¥è¿”å›é¢„æœŸç»“æœ', () {
  final result = newFeature.execute();
  expect(result, expectedValue);
});

// 2. å®ç°æœ€å°ä»£ç ä½¿æµ‹è¯•é€šè¿‡ (Green)
class NewFeature {
  execute() => expectedValue;
}

// 3. é‡æ„ä¼˜åŒ– (Refactor)
class NewFeature {
  execute() {
    // ä¼˜åŒ–å®ç°ï¼Œä¿æŒæµ‹è¯•é€šè¿‡
    return computeResult();
  }
}
```

#### é˜¶æ®µ3: æŒç»­æµ‹è¯•æ–‡åŒ– (æˆç†ŸæœŸ)

**ç›®æ ‡**: æµ‹è¯•é©±åŠ¨æˆä¸ºå›¢é˜Ÿä¹ æƒ¯

**æŒ‡æ ‡**:
- æ–°ä»£ç æµ‹è¯•è¦†ç›–ç‡ > 80%
- PRå¿…é¡»åŒ…å«æµ‹è¯•
- æµ‹è¯•å¤±è´¥é˜»æ­¢åˆå¹¶
- å®šæœŸæµ‹è¯•å€ºåŠ¡æ¸…ç†

---

## ğŸ“‹ å››ã€å…³é”®æµ‹è¯•ç”¨ä¾‹è¡¥å……æ–¹æ¡ˆ

### 4.1 TaskServiceæµ‹è¯•å¥—ä»¶

**æ–‡ä»¶**: `test/features/tasks/application/task_service_test.dart`

```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';
import 'package:mockito/annotations.dart';
import 'package:todolist/src/domain/entities/task.dart';
import 'package:todolist/src/domain/repositories/task_repository.dart';
import 'package:todolist/src/features/tasks/application/task_service.dart';
import 'package:todolist/src/core/utils/clock.dart';
import 'package:todolist/src/core/utils/id_generator.dart';
import 'package:todolist/src/core/logging/app_logger.dart';
import 'package:todolist/src/infrastructure/notifications/notification_service.dart';
import 'package:todolist/src/features/tasks/application/recurrence_service.dart';
import 'package:todolist/src/features/smart_reminders/application/smart_reminder_service.dart';

@GenerateMocks([
  TaskRepository,
  Clock,
  IdGenerator,
  AppLogger,
  NotificationService,
  RecurrenceService,
  SmartReminderService,
])
import 'task_service_test.mocks.dart';

void main() {
  group('TaskService', () {
    late TaskService service;
    late MockTaskRepository mockRepository;
    late MockClock mockClock;
    late MockIdGenerator mockIdGenerator;
    late MockAppLogger mockLogger;
    late MockNotificationService mockNotificationService;
    late MockRecurrenceService mockRecurrenceService;
    late MockSmartReminderService mockSmartReminderService;

    late DateTime testTime;

    setUp(() {
      mockRepository = MockTaskRepository();
      mockClock = MockClock();
      mockIdGenerator = MockIdGenerator();
      mockLogger = MockAppLogger();
      mockNotificationService = MockNotificationService();
      mockRecurrenceService = MockRecurrenceService();
      mockSmartReminderService = MockSmartReminderService();

      testTime = DateTime(2025, 10, 20, 10, 0);
      when(mockClock.now()).thenReturn(testTime);
      when(mockIdGenerator.generate()).thenReturn('test-id-123');

      service = TaskService(
        taskRepository: mockRepository,
        clock: mockClock,
        idGenerator: mockIdGenerator,
        logger: mockLogger,
        notificationService: mockNotificationService,
        recurrenceService: mockRecurrenceService,
        smartReminderService: mockSmartReminderService,
      );
    });

    group('createTask', () {
      test('åº”è¯¥åˆ›å»ºä»»åŠ¡å¹¶ç”Ÿæˆå”¯ä¸€ID', () async {
        // Arrange
        final input = TaskCreationInput(
          title: 'æµ‹è¯•ä»»åŠ¡',
          listId: 'list-1',
        );
        when(mockRepository.save(any)).thenAnswer((_) async {});
        when(mockNotificationService.syncTaskReminder(any))
            .thenAnswer((_) async {});

        // Act
        final result = await service.createTask(input);

        // Assert
        expect(result.id, 'test-id-123');
        expect(result.title, 'æµ‹è¯•ä»»åŠ¡');
        expect(result.createdAt, testTime);
        expect(result.updatedAt, testTime);
        expect(result.version, 1);

        verify(mockRepository.save(any)).called(1);
        verify(mockNotificationService.syncTaskReminder(any)).called(1);
      });

      test('åº”è¯¥ä¸ºé‡å¤ä»»åŠ¡è°ƒç”¨RecurrenceService', () async {
        // Arrange
        final rule = RecurrenceRule(
          frequency: RecurrenceFrequency.daily,
          interval: 1,
        );
        final input = TaskCreationInput(
          title: 'æ¯æ—¥ä»»åŠ¡',
          listId: 'list-1',
          recurrenceRule: rule,
        );
        when(mockRecurrenceService.createRecurringTask(any))
            .thenAnswer((_) async {});
        when(mockNotificationService.syncTaskReminder(any))
            .thenAnswer((_) async {});

        // Act
        await service.createTask(input);

        // Assert
        verify(mockRecurrenceService.createRecurringTask(any)).called(1);
        verifyNever(mockRepository.save(any));
      });

      test('æ™ºèƒ½æé†’åˆ›å»ºå¤±è´¥ä¸åº”å½±å“ä»»åŠ¡åˆ›å»º', () async {
        // Arrange
        final input = TaskCreationInput(
          title: 'æµ‹è¯•ä»»åŠ¡',
          listId: 'list-1',
          smartReminders: [
            SmartReminderConfig.time(
              scheduledAt: testTime.add(Duration(hours: 1)),
            ),
          ],
        );
        when(mockSmartReminderService.createFromNaturalLanguage(
          taskId: any,
          input: any,
        )).thenThrow(Exception('æé†’æœåŠ¡å¼‚å¸¸'));
        when(mockRepository.save(any)).thenAnswer((_) async {});
        when(mockNotificationService.syncTaskReminder(any))
            .thenAnswer((_) async {});

        // Act
        final result = await service.createTask(input);

        // Assert
        expect(result.smartReminderIds, isEmpty);
        verify(mockRepository.save(any)).called(1);
        verify(mockLogger.error(any, any, any)).called(1);
      });
    });

    group('updateTask', () {
      late Task existingTask;

      setUp(() {
        existingTask = Task(
          id: 'task-1',
          title: 'åŸä»»åŠ¡',
          listId: 'list-1',
          createdAt: testTime.subtract(Duration(days: 1)),
          updatedAt: testTime.subtract(Duration(days: 1)),
          version: 1,
        );
      });

      test('åº”è¯¥æ›´æ–°ä»»åŠ¡å¹¶å¢åŠ ç‰ˆæœ¬å·', () async {
        // Arrange
        final input = TaskUpdateInput(
          title: 'æ›´æ–°åä»»åŠ¡',
          listId: 'list-1',
          priority: TaskPriority.high,
        );
        when(mockRepository.save(any)).thenAnswer((_) async {});
        when(mockNotificationService.syncTaskReminder(any))
            .thenAnswer((_) async {});

        // Act
        final result = await service.updateTask(existingTask, input);

        // Assert
        expect(result.title, 'æ›´æ–°åä»»åŠ¡');
        expect(result.priority, TaskPriority.high);
        expect(result.version, 2);
        expect(result.updatedAt, testTime);
      });

      test('åº”è¯¥åˆ é™¤æ—§çš„æ™ºèƒ½æé†’', () async {
        // Arrange
        final taskWithReminders = existingTask.copyWith(
          smartReminderIds: ['reminder-1', 'reminder-2'],
        );
        final input = TaskUpdateInput(
          title: 'æ›´æ–°ä»»åŠ¡',
          listId: 'list-1',
        );
        when(mockSmartReminderService.deleteReminder(any))
            .thenAnswer((_) async {});
        when(mockRepository.save(any)).thenAnswer((_) async {});
        when(mockNotificationService.syncTaskReminder(any))
            .thenAnswer((_) async {});

        // Act
        await service.updateTask(taskWithReminders, input);

        // Assert
        verify(mockSmartReminderService.deleteReminder('reminder-1')).called(1);
        verify(mockSmartReminderService.deleteReminder('reminder-2')).called(1);
      });
    });

    group('toggleCompletion', () {
      late Task task;

      setUp(() {
        task = Task(
          id: 'task-1',
          title: 'æµ‹è¯•ä»»åŠ¡',
          listId: 'list-1',
          status: TaskStatus.pending,
          createdAt: testTime.subtract(Duration(hours: 1)),
          updatedAt: testTime.subtract(Duration(hours: 1)),
          version: 1,
        );
        when(mockRepository.save(any)).thenAnswer((_) async {});
        when(mockNotificationService.syncTaskReminder(any))
            .thenAnswer((_) async {});
      });

      test('å®Œæˆä»»åŠ¡åº”è¯¥è®¾ç½®completedAtæ—¶é—´', () async {
        // Act
        await service.toggleCompletion(task, isCompleted: true);

        // Assert
        final captured = verify(mockRepository.save(captureAny)).captured.single as Task;
        expect(captured.status, TaskStatus.completed);
        expect(captured.completedAt, testTime);
        expect(captured.version, 2);
      });

      test('å–æ¶ˆå®Œæˆåº”è¯¥æ¸…é™¤completedAtæ—¶é—´', () async {
        // Arrange
        final completedTask = task.copyWith(
          status: TaskStatus.completed,
          completedAt: testTime.subtract(Duration(hours: 1)),
        );

        // Act
        await service.toggleCompletion(completedTask, isCompleted: false);

        // Assert
        final captured = verify(mockRepository.save(captureAny)).captured.single as Task;
        expect(captured.status, TaskStatus.pending);
        expect(captured.completedAt, isNull);
      });

      test('å®Œæˆé‡å¤ä»»åŠ¡åº”è¯¥ç”Ÿæˆä¸‹ä¸€æ¬¡ä»»åŠ¡', () async {
        // Arrange
        final recurringTask = task.copyWith(
          recurrenceRule: RecurrenceRule(
            frequency: RecurrenceFrequency.daily,
            interval: 1,
          ),
        );
        when(mockRecurrenceService.handleRecurringTaskCompletion(any))
            .thenAnswer((_) async {});

        // Act
        await service.toggleCompletion(recurringTask, isCompleted: true);

        // Assert
        verify(mockRecurrenceService.handleRecurringTaskCompletion(any)).called(1);
      });
    });

    group('deleteTask', () {
      test('åº”è¯¥åˆ é™¤ä»»åŠ¡å’Œæ‰€æœ‰æ™ºèƒ½æé†’', () async {
        // Arrange
        final task = Task(
          id: 'task-1',
          title: 'æµ‹è¯•ä»»åŠ¡',
          listId: 'list-1',
          smartReminderIds: ['reminder-1', 'reminder-2', 'reminder-3'],
          createdAt: testTime,
          updatedAt: testTime,
        );
        when(mockSmartReminderService.deleteReminder(any))
            .thenAnswer((_) async {});
        when(mockRepository.delete(any)).thenAnswer((_) async {});
        when(mockNotificationService.cancelNotification(any))
            .thenAnswer((_) async {});

        // Act
        await service.deleteTask(task);

        // Assert
        verify(mockSmartReminderService.deleteReminder('reminder-1')).called(1);
        verify(mockSmartReminderService.deleteReminder('reminder-2')).called(1);
        verify(mockSmartReminderService.deleteReminder('reminder-3')).called(1);
        verify(mockRepository.delete('task-1')).called(1);
        verify(mockNotificationService.cancelNotification(any)).called(1);
      });

      test('æ™ºèƒ½æé†’åˆ é™¤å¤±è´¥ä¸åº”é˜»æ­¢ä»»åŠ¡åˆ é™¤', () async {
        // Arrange
        final task = Task(
          id: 'task-1',
          title: 'æµ‹è¯•ä»»åŠ¡',
          listId: 'list-1',
          smartReminderIds: ['reminder-1'],
          createdAt: testTime,
          updatedAt: testTime,
        );
        when(mockSmartReminderService.deleteReminder(any))
            .thenThrow(Exception('åˆ é™¤æé†’å¤±è´¥'));
        when(mockRepository.delete(any)).thenAnswer((_) async {});
        when(mockNotificationService.cancelNotification(any))
            .thenAnswer((_) async {});

        // Act
        await service.deleteTask(task);

        // Assert
        verify(mockRepository.delete('task-1')).called(1);
        verify(mockLogger.error(any, any, any)).called(1);
      });
    });
  });
}
```

**æµ‹è¯•è¦†ç›–ç‡**: é¢„è®¡80%+
**æµ‹è¯•æ•°é‡**: 15+ä¸ªæµ‹è¯•ç”¨ä¾‹
**æµ‹è¯•ç±»å‹**: å•å…ƒæµ‹è¯• + Mockæµ‹è¯•

### 4.2 RecurrenceServiceæµ‹è¯•å¥—ä»¶

**æ–‡ä»¶**: `test/features/tasks/application/recurrence_service_test.dart`

```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:mockito/mockito.dart';
import 'package:mockito/annotations.dart';
import 'package:todolist/src/domain/entities/task.dart';
import 'package:todolist/src/domain/entities/recurrence_rule.dart';
import 'package:todolist/src/domain/repositories/task_repository.dart';
import 'package:todolist/src/features/tasks/application/recurrence_service.dart';
import 'package:todolist/src/core/utils/clock.dart';
import 'package:todolist/src/core/utils/id_generator.dart';

@GenerateMocks([TaskRepository, Clock, IdGenerator])
import 'recurrence_service_test.mocks.dart';

void main() {
  group('RecurrenceService', () {
    late ProviderContainer container;
    late MockTaskRepository mockRepository;
    late MockClock mockClock;
    late MockIdGenerator mockIdGenerator;
    late RecurrenceService service;

    late DateTime baseTime;

    setUp(() {
      mockRepository = MockTaskRepository();
      mockClock = MockClock();
      mockIdGenerator = MockIdGenerator();

      baseTime = DateTime(2025, 10, 20, 10, 0);
      when(mockClock.now()).thenReturn(baseTime);
      when(mockIdGenerator.generate()).thenReturn('next-task-id');

      container = ProviderContainer(
        overrides: [
          taskRepositoryProvider.overrideWithValue(mockRepository),
          clockProvider.overrideWithValue(mockClock),
          idGeneratorProvider.overrideWithValue(mockIdGenerator),
        ],
      );

      service = RecurrenceService(container.read);
    });

    tearDown(() {
      container.dispose();
    });

    group('handleRecurringTaskCompletion - æ¯æ—¥é‡å¤', () {
      test('åº”è¯¥ç”Ÿæˆæ˜å¤©çš„ä»»åŠ¡', () async {
        // Arrange
        final rule = RecurrenceRule(
          frequency: RecurrenceFrequency.daily,
          interval: 1,
        );
        final task = Task(
          id: 'task-1',
          title: 'æ¯æ—¥ä»»åŠ¡',
          listId: 'list-1',
          status: TaskStatus.completed,
          dueAt: baseTime,
          remindAt: baseTime.subtract(Duration(hours: 1)),
          recurrenceRule: rule,
          parentRecurringTaskId: 'task-1',
          recurrenceCount: 0,
          createdAt: baseTime.subtract(Duration(days: 1)),
          updatedAt: baseTime,
        );
        when(mockRepository.save(any)).thenAnswer((_) async {});

        // Act
        await service.handleRecurringTaskCompletion(task);

        // Assert
        final captured = verify(mockRepository.save(captureAny)).captured.single as Task;
        expect(captured.id, 'next-task-id');
        expect(captured.status, TaskStatus.pending);
        expect(captured.dueAt, baseTime.add(Duration(days: 1)));
        expect(captured.remindAt, baseTime.add(Duration(days: 1)).subtract(Duration(hours: 1)));
        expect(captured.recurrenceCount, 1);
      });

      test('æ¯2å¤©é‡å¤åº”è¯¥ç”Ÿæˆåå¤©çš„ä»»åŠ¡', () async {
        // Arrange
        final rule = RecurrenceRule(
          frequency: RecurrenceFrequency.daily,
          interval: 2,
        );
        final task = Task(
          id: 'task-1',
          title: 'æ¯2å¤©ä»»åŠ¡',
          listId: 'list-1',
          status: TaskStatus.completed,
          dueAt: baseTime,
          recurrenceRule: rule,
          parentRecurringTaskId: 'task-1',
          recurrenceCount: 0,
          createdAt: baseTime.subtract(Duration(days: 2)),
          updatedAt: baseTime,
        );
        when(mockRepository.save(any)).thenAnswer((_) async {});

        // Act
        await service.handleRecurringTaskCompletion(task);

        // Assert
        final captured = verify(mockRepository.save(captureAny)).captured.single as Task;
        expect(captured.dueAt, baseTime.add(Duration(days: 2)));
      });
    });

    group('handleRecurringTaskCompletion - æ¯å‘¨é‡å¤', () {
      test('åº”è¯¥ç”Ÿæˆä¸‹å‘¨åŒä¸€å¤©çš„ä»»åŠ¡', () async {
        // Arrange
        final monday = DateTime(2025, 10, 20); // å‡è®¾æ˜¯å‘¨ä¸€
        final rule = RecurrenceRule(
          frequency: RecurrenceFrequency.weekly,
          interval: 1,
          byWeekday: [1], // å‘¨ä¸€
        );
        final task = Task(
          id: 'task-1',
          title: 'æ¯å‘¨ä¸€ä»»åŠ¡',
          listId: 'list-1',
          status: TaskStatus.completed,
          dueAt: monday,
          recurrenceRule: rule,
          parentRecurringTaskId: 'task-1',
          recurrenceCount: 0,
          createdAt: monday.subtract(Duration(days: 7)),
          updatedAt: monday,
        );
        when(mockClock.now()).thenReturn(monday);
        when(mockRepository.save(any)).thenAnswer((_) async {});

        // Act
        await service.handleRecurringTaskCompletion(task);

        // Assert
        final captured = verify(mockRepository.save(captureAny)).captured.single as Task;
        expect(captured.dueAt, monday.add(Duration(days: 7)));
      });
    });

    group('handleRecurringTaskCompletion - ç»“æŸæ¡ä»¶', () {
      test('è¾¾åˆ°æœ€å¤§æ¬¡æ•°åä¸åº”ç”Ÿæˆæ–°ä»»åŠ¡', () async {
        // Arrange
        final rule = RecurrenceRule(
          frequency: RecurrenceFrequency.daily,
          interval: 1,
          count: 5, // æœ€å¤š5æ¬¡
        );
        final task = Task(
          id: 'task-1',
          title: 'é™å®šæ¬¡æ•°ä»»åŠ¡',
          listId: 'list-1',
          status: TaskStatus.completed,
          dueAt: baseTime,
          recurrenceRule: rule,
          parentRecurringTaskId: 'task-1',
          recurrenceCount: 4, // å·²å®Œæˆ4æ¬¡ï¼Œè¿™æ˜¯ç¬¬5æ¬¡
          createdAt: baseTime.subtract(Duration(days: 5)),
          updatedAt: baseTime,
        );

        // Act
        await service.handleRecurringTaskCompletion(task);

        // Assert
        verifyNever(mockRepository.save(any));
      });

      test('è¶…è¿‡ç»“æŸæ—¥æœŸåä¸åº”ç”Ÿæˆæ–°ä»»åŠ¡', () async {
        // Arrange
        final endDate = baseTime.add(Duration(days: 1));
        final rule = RecurrenceRule(
          frequency: RecurrenceFrequency.daily,
          interval: 1,
          until: endDate,
        );
        final task = Task(
          id: 'task-1',
          title: 'é™å®šæ—¥æœŸä»»åŠ¡',
          listId: 'list-1',
          status: TaskStatus.completed,
          dueAt: baseTime,
          recurrenceRule: rule,
          parentRecurringTaskId: 'task-1',
          recurrenceCount: 10,
          createdAt: baseTime.subtract(Duration(days: 10)),
          updatedAt: baseTime,
        );
        when(mockClock.now()).thenReturn(endDate.add(Duration(days: 1)));

        // Act
        await service.handleRecurringTaskCompletion(task);

        // Assert
        verifyNever(mockRepository.save(any));
      });
    });

    group('handleRecurringTaskCompletion - æé†’æ—¶é—´', () {
      test('åº”è¯¥ä¿æŒæé†’æ—¶é—´ä¸åˆ°æœŸæ—¶é—´çš„åç§»', () async {
        // Arrange
        final rule = RecurrenceRule(
          frequency: RecurrenceFrequency.daily,
          interval: 1,
        );
        final dueTime = baseTime.add(Duration(hours: 14));
        final remindTime = dueTime.subtract(Duration(hours: 2)); // æå‰2å°æ—¶
        final task = Task(
          id: 'task-1',
          title: 'æœ‰æé†’çš„ä»»åŠ¡',
          listId: 'list-1',
          status: TaskStatus.completed,
          dueAt: dueTime,
          remindAt: remindTime,
          recurrenceRule: rule,
          parentRecurringTaskId: 'task-1',
          recurrenceCount: 0,
          createdAt: baseTime,
          updatedAt: baseTime,
        );
        when(mockRepository.save(any)).thenAnswer((_) async {});

        // Act
        await service.handleRecurringTaskCompletion(task);

        // Assert
        final captured = verify(mockRepository.save(captureAny)).captured.single as Task;
        final nextDue = captured.dueAt!;
        final nextRemind = captured.remindAt!;
        expect(nextDue.difference(nextRemind).inHours, 2);
      });
    });

    group('createRecurringTask', () {
      test('æ™®é€šä»»åŠ¡åº”è¯¥ç›´æ¥ä¿å­˜', () async {
        // Arrange
        final task = Task(
          id: 'task-1',
          title: 'æ™®é€šä»»åŠ¡',
          listId: 'list-1',
          createdAt: baseTime,
          updatedAt: baseTime,
        );
        when(mockRepository.save(any)).thenAnswer((_) async {});

        // Act
        await service.createRecurringTask(task);

        // Assert
        verify(mockRepository.save(task)).called(1);
      });

      test('é‡å¤ä»»åŠ¡åº”è¯¥è®¾ç½®parentRecurringTaskId', () async {
        // Arrange
        final rule = RecurrenceRule(
          frequency: RecurrenceFrequency.daily,
          interval: 1,
        );
        final task = Task(
          id: 'task-1',
          title: 'é‡å¤ä»»åŠ¡',
          listId: 'list-1',
          recurrenceRule: rule,
          createdAt: baseTime,
          updatedAt: baseTime,
        );
        when(mockRepository.save(any)).thenAnswer((_) async {});

        // Act
        await service.createRecurringTask(task);

        // Assert
        final captured = verify(mockRepository.save(captureAny)).captured.single as Task;
        expect(captured.parentRecurringTaskId, 'task-1');
      });
    });

    group('deleteRecurringSeries', () {
      test('åº”è¯¥åˆ é™¤æ‰€æœ‰æœªå®Œæˆçš„ç³»åˆ—ä»»åŠ¡', () async {
        // Arrange
        final completedTask = Task(
          id: 'task-1',
          title: 'å·²å®Œæˆä»»åŠ¡',
          listId: 'list-1',
          status: TaskStatus.completed,
          parentRecurringTaskId: 'parent-1',
          createdAt: baseTime.subtract(Duration(days: 2)),
          updatedAt: baseTime.subtract(Duration(days: 2)),
        );
        final pendingTask1 = Task(
          id: 'task-2',
          title: 'æœªå®Œæˆä»»åŠ¡1',
          listId: 'list-1',
          status: TaskStatus.pending,
          parentRecurringTaskId: 'parent-1',
          createdAt: baseTime.subtract(Duration(days: 1)),
          updatedAt: baseTime.subtract(Duration(days: 1)),
        );
        final pendingTask2 = Task(
          id: 'task-3',
          title: 'æœªå®Œæˆä»»åŠ¡2',
          listId: 'list-1',
          status: TaskStatus.inProgress,
          parentRecurringTaskId: 'parent-1',
          createdAt: baseTime,
          updatedAt: baseTime,
        );

        when(mockRepository.watchAll()).thenAnswer(
          (_) => Stream.value([completedTask, pendingTask1, pendingTask2]),
        );
        when(mockRepository.delete(any)).thenAnswer((_) async {});

        // Act
        await service.deleteRecurringSeries('parent-1');

        // Assert
        verify(mockRepository.delete('task-2')).called(1);
        verify(mockRepository.delete('task-3')).called(1);
        verifyNever(mockRepository.delete('task-1')); // å·²å®Œæˆçš„ä¸åˆ é™¤
      });
    });
  });
}
```

**æµ‹è¯•è¦†ç›–ç‡**: é¢„è®¡90%+
**æµ‹è¯•æ•°é‡**: 18+ä¸ªæµ‹è¯•ç”¨ä¾‹
**æµ‹è¯•åœºæ™¯**: æ¯æ—¥/æ¯å‘¨/æ¯æœˆé‡å¤ï¼Œç»“æŸæ¡ä»¶ï¼Œæé†’æ—¶é—´ç­‰

### 4.3 HiveTaskRepositoryæµ‹è¯•å¥—ä»¶

**æ–‡ä»¶**: `test/infrastructure/repositories/hive_task_repository_test.dart`

```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:hive_flutter/hive_flutter.dart';
import 'package:todolist/src/domain/entities/task.dart';
import 'package:todolist/src/infrastructure/repositories/hive_task_repository.dart';

void main() {
  group('HiveTaskRepository', () {
    late Box<Task> mockBox;
    late HiveTaskRepository repository;

    setUpAll(() async {
      // åˆå§‹åŒ–Hiveæµ‹è¯•ç¯å¢ƒ
      await Hive.initFlutter();

      // æ³¨å†Œé€‚é…å™¨
      if (!Hive.isAdapterRegistered(0)) {
        Hive.registerAdapter(TaskAdapter());
      }
      if (!Hive.isAdapterRegistered(4)) {
        Hive.registerAdapter(TaskPriorityAdapter());
      }
      if (!Hive.isAdapterRegistered(5)) {
        Hive.registerAdapter(TaskStatusAdapter());
      }
    });

    setUp(() async {
      // æ¯ä¸ªæµ‹è¯•ä½¿ç”¨ç‹¬ç«‹çš„å†…å­˜Box
      mockBox = await Hive.openBox<Task>('test_tasks_${DateTime.now().millisecondsSinceEpoch}');
      repository = HiveTaskRepository(mockBox);
    });

    tearDown(() async {
      await mockBox.clear();
      await mockBox.close();
    });

    group('åŸºç¡€CRUDæ“ä½œ', () {
      test('ä¿å­˜ä»»åŠ¡åº”è¯¥æˆåŠŸå­˜å‚¨', () async {
        // Arrange
        final task = Task(
          id: 'task-1',
          title: 'æµ‹è¯•ä»»åŠ¡',
          listId: 'list-1',
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
        );

        // Act
        await repository.save(task);

        // Assert
        final saved = mockBox.get('task-1');
        expect(saved, isNotNull);
        expect(saved!.title, 'æµ‹è¯•ä»»åŠ¡');
      });

      test('è·å–ä»»åŠ¡åº”è¯¥è¿”å›æ­£ç¡®å¯¹è±¡', () async {
        // Arrange
        final task = Task(
          id: 'task-1',
          title: 'æµ‹è¯•ä»»åŠ¡',
          listId: 'list-1',
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
        );
        await mockBox.put('task-1', task);

        // Act
        final result = await repository.getById('task-1');

        // Assert
        expect(result, isNotNull);
        expect(result!.id, 'task-1');
        expect(result.title, 'æµ‹è¯•ä»»åŠ¡');
      });

      test('è·å–ä¸å­˜åœ¨çš„ä»»åŠ¡åº”è¯¥è¿”å›null', () async {
        // Act
        final result = await repository.getById('non-existent');

        // Assert
        expect(result, isNull);
      });

      test('åˆ é™¤ä»»åŠ¡åº”è¯¥ä»æ•°æ®åº“ç§»é™¤', () async {
        // Arrange
        final task = Task(
          id: 'task-1',
          title: 'æµ‹è¯•ä»»åŠ¡',
          listId: 'list-1',
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
        );
        await mockBox.put('task-1', task);

        // Act
        await repository.delete('task-1');

        // Assert
        final deleted = mockBox.get('task-1');
        expect(deleted, isNull);
      });

      test('æ‰¹é‡ä¿å­˜åº”è¯¥ä¸€æ¬¡æ€§ä¿å­˜å¤šä¸ªä»»åŠ¡', () async {
        // Arrange
        final tasks = List.generate(10, (i) => Task(
          id: 'task-$i',
          title: 'ä»»åŠ¡$i',
          listId: 'list-1',
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
        ));

        // Act
        await repository.saveAll(tasks);

        // Assert
        expect(mockBox.length, 10);
        for (var i = 0; i < 10; i++) {
          expect(mockBox.get('task-$i'), isNotNull);
        }
      });

      test('æ¸…ç©ºåº”è¯¥åˆ é™¤æ‰€æœ‰ä»»åŠ¡', () async {
        // Arrange
        await mockBox.put('task-1', Task(
          id: 'task-1',
          title: 'ä»»åŠ¡1',
          listId: 'list-1',
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
        ));
        await mockBox.put('task-2', Task(
          id: 'task-2',
          title: 'ä»»åŠ¡2',
          listId: 'list-1',
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
        ));

        // Act
        await repository.clear();

        // Assert
        expect(mockBox.length, 0);
      });
    });

    group('æŸ¥è¯¢åŠŸèƒ½', () {
      test('æŒ‰æ—¥æœŸèŒƒå›´æŸ¥è¯¢åº”è¯¥è¿”å›æ­£ç¡®ä»»åŠ¡', () async {
        // Arrange
        final now = DateTime.now();
        final yesterday = now.subtract(Duration(days: 1));
        final tomorrow = now.add(Duration(days: 1));
        final nextWeek = now.add(Duration(days: 7));

        await repository.saveAll([
          Task(
            id: 'task-1',
            title: 'æ˜¨å¤©åˆ°æœŸ',
            listId: 'list-1',
            dueAt: yesterday,
            createdAt: now,
            updatedAt: now,
          ),
          Task(
            id: 'task-2',
            title: 'æ˜å¤©åˆ°æœŸ',
            listId: 'list-1',
            dueAt: tomorrow,
            createdAt: now,
            updatedAt: now,
          ),
          Task(
            id: 'task-3',
            title: 'ä¸‹å‘¨åˆ°æœŸ',
            listId: 'list-1',
            dueAt: nextWeek,
            createdAt: now,
            updatedAt: now,
          ),
        ]);

        // Act
        final result = await repository.findDueBetween(
          start: now,
          end: now.add(Duration(days: 3)),
        );

        // Assert
        expect(result.length, 1);
        expect(result[0].id, 'task-2');
      });

      test('è·å–æ‰€æœ‰ä»»åŠ¡åº”è¯¥æŒ‰æ—¶é—´æ’åº', () async {
        // Arrange
        final now = DateTime.now();
        await repository.saveAll([
          Task(
            id: 'task-3',
            title: 'ç¬¬ä¸‰ä¸ª',
            listId: 'list-1',
            dueAt: now.add(Duration(days: 3)),
            createdAt: now,
            updatedAt: now,
          ),
          Task(
            id: 'task-1',
            title: 'ç¬¬ä¸€ä¸ª',
            listId: 'list-1',
            dueAt: now.add(Duration(days: 1)),
            createdAt: now,
            updatedAt: now,
          ),
          Task(
            id: 'task-2',
            title: 'ç¬¬äºŒä¸ª',
            listId: 'list-1',
            dueAt: now.add(Duration(days: 2)),
            createdAt: now,
            updatedAt: now,
          ),
        ]);

        // Act
        final result = await repository.getAll();

        // Assert
        expect(result.length, 3);
        expect(result[0].id, 'task-1');
        expect(result[1].id, 'task-2');
        expect(result[2].id, 'task-3');
      });
    });

    group('ç¼“å­˜æ€§èƒ½', () {
      test('é¦–æ¬¡è·å–ä»»åŠ¡åº”è¯¥ç¼“å­˜ç»“æœ', () async {
        // Arrange
        final now = DateTime.now();
        await repository.save(Task(
          id: 'task-1',
          title: 'æµ‹è¯•ä»»åŠ¡',
          listId: 'list-1',
          createdAt: now,
          updatedAt: now,
        ));

        // Act
        await repository.getAll();
        await repository.getAll();

        // Assert
        final stats = repository.getPerformanceStats();
        expect(stats['cacheHits'], greaterThan(0));
      });

      test('æ€§èƒ½ç»Ÿè®¡åº”è¯¥æ­£ç¡®è®°å½•æŒ‡æ ‡', () async {
        // Arrange
        repository.resetPerformanceStats();
        final now = DateTime.now();

        // Act - å¤šæ¬¡æ“ä½œ
        await repository.save(Task(
          id: 'task-1',
          title: 'ä»»åŠ¡1',
          listId: 'list-1',
          createdAt: now,
          updatedAt: now,
        ));
        await repository.getAll();
        await repository.getAll();
        await repository.save(Task(
          id: 'task-2',
          title: 'ä»»åŠ¡2',
          listId: 'list-1',
          createdAt: now,
          updatedAt: now,
        ));

        // Assert
        final stats = repository.getPerformanceStats();
        expect(stats['cacheHits'], greaterThanOrEqualTo(1));
        expect(stats['cacheMisses'], greaterThanOrEqualTo(1));
        expect(stats['incrementalUpdates'], greaterThanOrEqualTo(0));
      });
    });

    group('Streamç›‘å¬', () {
      test('watchAllåº”è¯¥ç›‘å¬ä»»åŠ¡å˜åŒ–', () async {
        // Arrange
        final stream = repository.watchAll();
        final emittedValues = <List<Task>>[];

        // Act
        final subscription = stream.listen(emittedValues.add);
        await Future.delayed(Duration(milliseconds: 100));

        await repository.save(Task(
          id: 'task-1',
          title: 'æ–°ä»»åŠ¡',
          listId: 'list-1',
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
        ));

        await Future.delayed(Duration(milliseconds: 100));
        await subscription.cancel();

        // Assert
        expect(emittedValues.length, greaterThanOrEqualTo(2));
        expect(emittedValues.last.length, 1);
        expect(emittedValues.last[0].id, 'task-1');
      });

      test('watchByIdåº”è¯¥ç›‘å¬å•ä¸ªä»»åŠ¡å˜åŒ–', () async {
        // Arrange
        await repository.save(Task(
          id: 'task-1',
          title: 'åŸæ ‡é¢˜',
          listId: 'list-1',
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
        ));

        final stream = repository.watchById('task-1');
        final emittedValues = <Task?>[];

        // Act
        final subscription = stream.listen(emittedValues.add);
        await Future.delayed(Duration(milliseconds: 100));

        await repository.save(Task(
          id: 'task-1',
          title: 'æ–°æ ‡é¢˜',
          listId: 'list-1',
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
        ));

        await Future.delayed(Duration(milliseconds: 100));
        await subscription.cancel();

        // Assert
        expect(emittedValues.length, greaterThanOrEqualTo(2));
        expect(emittedValues.last?.title, 'æ–°æ ‡é¢˜');
      });
    });
  });
}
```

**æµ‹è¯•è¦†ç›–ç‡**: é¢„è®¡85%+
**æµ‹è¯•æ•°é‡**: 16+ä¸ªæµ‹è¯•ç”¨ä¾‹
**æµ‹è¯•é‡ç‚¹**: CRUDã€æŸ¥è¯¢ã€ç¼“å­˜ã€Streamç›‘å¬

---

## ğŸ”§ äº”ã€æµ‹è¯•è‡ªåŠ¨åŒ–ä¸CI/CDé›†æˆ

### 5.1 ä¿®å¤ç°æœ‰æµ‹è¯•

**é—®é¢˜**: `widget_test.dart` å› Hiveæœªåˆå§‹åŒ–è€Œå¤±è´¥

**è§£å†³æ–¹æ¡ˆ**:

```dart
// test/widget_test.dart (ä¿®å¤å)
import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:hive_flutter/hive_flutter.dart';
import 'package:todolist/l10n/app_localizations.dart';
import 'package:todolist/src/domain/entities/task.dart';
import 'package:todolist/src/features/home/application/home_tasks_provider.dart';
import 'package:todolist/src/features/home/presentation/home_page.dart';

void main() {
  setUpAll(() async {
    // åˆå§‹åŒ–Hiveç”¨äºæµ‹è¯•
    await Hive.initFlutter();

    // æ³¨å†Œæ‰€æœ‰å¿…è¦çš„Adapter
    Hive.registerAdapter(TaskAdapter());
    Hive.registerAdapter(TaskPriorityAdapter());
    Hive.registerAdapter(TaskStatusAdapter());
    // ... æ³¨å†Œå…¶ä»–Adapter
  });

  testWidgets('Home page shows empty state when no tasks', (tester) async {
    // åˆ›å»ºä¸´æ—¶æµ‹è¯•Box
    final testBox = await Hive.openBox<Task>('test_tasks_${DateTime.now().millisecondsSinceEpoch}');

    await tester.pumpWidget(
      ProviderScope(
        overrides: [
          todayTasksProvider.overrideWith(
            (ref) => Stream.value(const []),
          ),
        ],
        child: MaterialApp(
          localizationsDelegates: const [
            AppLocalizations.delegate,
            GlobalMaterialLocalizations.delegate,
            GlobalWidgetsLocalizations.delegate,
            GlobalCupertinoLocalizations.delegate,
          ],
          supportedLocales: AppLocalizations.supportedLocales,
          home: const HomePage(),
        ),
      ),
    );

    await tester.pumpAndSettle();

    // éªŒè¯ç©ºçŠ¶æ€æ˜¾ç¤º
    expect(find.text('Nothing planned yet'), findsOneWidget);

    // æ¸…ç†
    await testBox.clear();
    await testBox.close();
  });
}
```

### 5.2 GitHub Actions CIé…ç½®

**æ–‡ä»¶**: `.github/workflows/flutter_test.yml`

```yaml
name: Flutteræµ‹è¯•ä¸è¦†ç›–ç‡

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    name: è¿è¡ŒFlutteræµ‹è¯•
    runs-on: ubuntu-latest

    steps:
      - name: æ£€å‡ºä»£ç 
        uses: actions/checkout@v3

      - name: è®¾ç½®Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: '3.22.0'
          channel: 'stable'

      - name: è·å–ä¾èµ–
        run: flutter pub get

      - name: åˆ†æä»£ç 
        run: flutter analyze

      - name: è¿è¡Œå•å…ƒæµ‹è¯•å’ŒWidgetæµ‹è¯•
        run: flutter test --coverage --reporter=expanded

      - name: ä¸Šä¼ è¦†ç›–ç‡æŠ¥å‘Šåˆ°Codecov
        uses: codecov/codecov-action@v3
        with:
          file: coverage/lcov.info
          flags: unittests
          name: flutter-coverage
          fail_ci_if_error: false

      - name: ç”Ÿæˆè¦†ç›–ç‡HTMLæŠ¥å‘Š
        run: |
          sudo apt-get install -y lcov
          genhtml coverage/lcov.info -o coverage/html

      - name: ä¸Šä¼ è¦†ç›–ç‡HTMLæŠ¥å‘Š
        uses: actions/upload-artifact@v3
        with:
          name: coverage-report
          path: coverage/html

      - name: æ£€æŸ¥æµ‹è¯•è¦†ç›–ç‡é˜ˆå€¼
        run: |
          COVERAGE=$(lcov --summary coverage/lcov.info | grep lines | awk '{print $2}' | sed 's/%//')
          echo "å½“å‰è¦†ç›–ç‡: $COVERAGE%"
          if (( $(echo "$COVERAGE < 30" | bc -l) )); then
            echo "è­¦å‘Š: æµ‹è¯•è¦†ç›–ç‡ä½äº30%"
            exit 0  # æš‚ä¸å¼ºåˆ¶å¤±è´¥ï¼Œä»…è­¦å‘Š
          fi

  integration-test:
    name: è¿è¡Œé›†æˆæµ‹è¯•
    runs-on: macos-latest  # iOSæ¨¡æ‹Ÿå™¨éœ€è¦macOS

    steps:
      - name: æ£€å‡ºä»£ç 
        uses: actions/checkout@v3

      - name: è®¾ç½®Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: '3.22.0'

      - name: è·å–ä¾èµ–
        run: flutter pub get

      - name: è¿è¡Œé›†æˆæµ‹è¯•
        run: flutter test integration_test
        continue-on-error: true  # é›†æˆæµ‹è¯•å¯é€‰

  quality-gate:
    name: è´¨é‡é—¨ç¦
    needs: [test]
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'

    steps:
      - name: æ£€æŸ¥æµ‹è¯•ç»“æœ
        run: |
          echo "æ‰€æœ‰æµ‹è¯•å·²é€šè¿‡"
          echo "å¯ä»¥åˆå¹¶PR"
```

### 5.3 Pre-commit Hooké…ç½®

**æ–‡ä»¶**: `.husky/pre-commit`

```bash
#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

echo "ğŸ§ª è¿è¡Œæµ‹è¯•..."

# è¿è¡Œå¿«é€Ÿæµ‹è¯•å¥—ä»¶
flutter test --no-pub

# æ£€æŸ¥æµ‹è¯•ç»“æœ
if [ $? -ne 0 ]; then
  echo "âŒ æµ‹è¯•å¤±è´¥ï¼Œæäº¤å·²é˜»æ­¢"
  echo "è¯·ä¿®å¤æµ‹è¯•åå†æäº¤"
  exit 1
fi

echo "âœ… æ‰€æœ‰æµ‹è¯•é€šè¿‡"

# è¿è¡Œä»£ç åˆ†æ
echo "ğŸ” åˆ†æä»£ç ..."
flutter analyze

if [ $? -ne 0 ]; then
  echo "âš ï¸  ä»£ç åˆ†æå‘ç°é—®é¢˜ï¼Œè¯·ä¿®å¤"
  exit 1
fi

echo "âœ… ä»£ç åˆ†æé€šè¿‡"
exit 0
```

---

## ğŸ“ˆ å…­ã€æµ‹è¯•æŒ‡æ ‡ç›‘æ§

### 6.1 å…³é”®æŒ‡æ ‡å®šä¹‰

| æŒ‡æ ‡ | å½“å‰å€¼ | 4å‘¨ç›®æ ‡ | 12å‘¨ç›®æ ‡ | æœ€ç»ˆç›®æ ‡ |
|------|--------|---------|----------|----------|
| å•å…ƒæµ‹è¯•è¦†ç›–ç‡ | <1% | 30% | 60% | 70% |
| Widgetæµ‹è¯•è¦†ç›–ç‡ | <0.5% | 10% | 30% | 50% |
| é›†æˆæµ‹è¯•è¦†ç›–ç‡ | 3% | 8% | 15% | 20% |
| æµ‹è¯•æ•°é‡ | 29ä¸ª | 150+ | 400+ | 600+ |
| æµ‹è¯•æ–‡ä»¶æ•° | 4ä¸ª | 30+ | 80+ | 120+ |
| æµ‹è¯•æ‰§è¡Œæ—¶é—´ | <10ç§’ | <1åˆ†é’Ÿ | <3åˆ†é’Ÿ | <5åˆ†é’Ÿ |
| æµ‹è¯•ç¨³å®šæ€§ | N/A | 95% | 98% | 99% |
| CIé€šè¿‡ç‡ | N/A | 80% | 90% | 95% |

### 6.2 æ¯å‘¨æµ‹è¯•æŠ¥å‘Šæ¨¡æ¿

```markdown
# æµ‹è¯•å‘¨æŠ¥ - ç¬¬Xå‘¨ (YYYY-MM-DD)

## ğŸ“Š æµ‹è¯•ç»Ÿè®¡
- **æ–°å¢æµ‹è¯•ç”¨ä¾‹**: XXä¸ª
- **æ–°å¢æµ‹è¯•æ–‡ä»¶**: XXä¸ª
- **å½“å‰æ€»æµ‹è¯•æ•°**: XXXä¸ª
- **å½“å‰è¦†ç›–ç‡**: XX.X%
- **è¦†ç›–ç‡å˜åŒ–**: â†‘/â†“ X.X%

## ğŸ¯ æœ¬å‘¨å®Œæˆ
1. âœ… å®ŒæˆTaskServiceæµ‹è¯•å¥—ä»¶ (15ä¸ªæµ‹è¯•)
2. âœ… ä¿®å¤widget_test.dart Hiveåˆå§‹åŒ–é—®é¢˜
3. âœ… é…ç½®CI/CDè‡ªåŠ¨åŒ–æµ‹è¯•
4. âœ… ç¼–å†™æµ‹è¯•å·¥å…·ç±»å’ŒMockåŸºç±»

## ğŸ› å‘ç°çš„Bug
1. ä»»åŠ¡åˆ é™¤æ—¶æ™ºèƒ½æé†’æœªæ¸…ç† (å·²ä¿®å¤)
2. é‡å¤ä»»åŠ¡å®Œæˆæ¬¡æ•°è®¡æ•°é”™è¯¯ (ä¿®å¤ä¸­)
3. ç¼“å­˜å¤±æ•ˆé€»è¾‘æœ‰æ¼æ´ (å¾…ä¿®å¤)

## ğŸ“ˆ è¦†ç›–ç‡è¯¦æƒ…
| æ¨¡å— | è¦†ç›–ç‡ | å˜åŒ– |
|------|--------|------|
| ä»»åŠ¡ç®¡ç† | 85% | â†‘ 85% |
| é‡å¤ä»»åŠ¡ | 90% | â†‘ 90% |
| æ•°æ®æŒä¹…åŒ– | 75% | â†‘ 75% |
| äº‘åŒæ­¥ | 0% | - |

## ğŸ¯ ä¸‹å‘¨è®¡åˆ’
1. å®ŒæˆRecurrenceServiceæµ‹è¯• (18ä¸ªæµ‹è¯•)
2. å®ŒæˆHiveTaskRepositoryæµ‹è¯• (16ä¸ªæµ‹è¯•)
3. å¼€å§‹CloudSyncServiceæµ‹è¯•
4. ç¼–å†™Widgetæµ‹è¯•åŸºç¡€è®¾æ–½

## âš ï¸ é£é™©ä¸é—®é¢˜
- Hiveæµ‹è¯•ç¯å¢ƒé…ç½®å¤æ‚ï¼Œéœ€è¦æ›´å¥½çš„æµ‹è¯•è¾…åŠ©å·¥å…·
- Mockå¯¹è±¡åˆ›å»ºç¹çï¼Œè€ƒè™‘ä½¿ç”¨ä»£ç ç”Ÿæˆ
- é›†æˆæµ‹è¯•ç¯å¢ƒæ­å»ºéœ€è¦æ›´å¤šæ—¶é—´

## ğŸ’¡ æ”¹è¿›å»ºè®®
1. å»ºç«‹æµ‹è¯•æ•°æ®Factoryæ¨¡å¼
2. ç»Ÿä¸€æµ‹è¯•å‘½åè§„èŒƒ
3. ç¼–å†™æµ‹è¯•æœ€ä½³å®è·µæ–‡æ¡£
```

---

## ğŸš€ ä¸ƒã€å®æ–½è·¯çº¿å›¾

### ç¬¬1å‘¨: æµ‹è¯•åŸºç¡€è®¾æ–½ (2025-10-21 ~ 10-27)

**ç›®æ ‡**: å»ºç«‹æµ‹è¯•ç¯å¢ƒå’Œå·¥å…·

**ä»»åŠ¡æ¸…å•**:
- [ ] ä¿®å¤widget_test.dart Hiveåˆå§‹åŒ–é—®é¢˜
- [ ] æ·»åŠ æµ‹è¯•ä¾èµ– (faker, golden_toolkitç­‰)
- [ ] åˆ›å»ºæµ‹è¯•ç›®å½•ç»“æ„
  ```
  test/
  â”œâ”€â”€ helpers/          # æµ‹è¯•è¾…åŠ©å·¥å…·
  â”‚   â”œâ”€â”€ test_data_factory.dart
  â”‚   â”œâ”€â”€ mock_providers.dart
  â”‚   â””â”€â”€ hive_test_setup.dart
  â”œâ”€â”€ mocks/            # Mockå¯¹è±¡
  â”œâ”€â”€ fixtures/         # æµ‹è¯•æ•°æ®
  â””â”€â”€ unit/             # å•å…ƒæµ‹è¯•
      â”œâ”€â”€ domain/
      â”œâ”€â”€ features/
      â””â”€â”€ infrastructure/
  ```
- [ ] ç¼–å†™æµ‹è¯•å·¥å…·ç±»
- [ ] é…ç½®GitHub Actions CI
- [ ] ç¼–å†™æµ‹è¯•æŒ‡å—æ–‡æ¡£

**äº¤ä»˜ç‰©**:
- ä¿®å¤åçš„æµ‹è¯•å¥—ä»¶(4ä¸ªæµ‹è¯•å…¨éƒ¨é€šè¿‡)
- æµ‹è¯•è¾…åŠ©å·¥å…·ç±»åº“
- CI/CDé…ç½®æ–‡ä»¶
- æµ‹è¯•æŒ‡å—æ–‡æ¡£(README_TESTING.md)

**è¦†ç›–ç‡ç›®æ ‡**: ä¿æŒ<1% (é‡ç‚¹åœ¨åŸºç¡€è®¾æ–½)

### ç¬¬2å‘¨: æ ¸å¿ƒä¸šåŠ¡é€»è¾‘æµ‹è¯• (2025-10-28 ~ 11-03)

**ç›®æ ‡**: æµ‹è¯•å…³é”®Serviceå±‚

**ä¼˜å…ˆæµ‹è¯•æ¨¡å—**:
1. TaskService (15ä¸ªæµ‹è¯•)
2. RecurrenceService (18ä¸ªæµ‹è¯•)
3. SmartReminderService (12ä¸ªæµ‹è¯•)

**æµ‹è¯•é‡ç‚¹**:
- ä»»åŠ¡åˆ›å»º/æ›´æ–°/åˆ é™¤é€»è¾‘
- é‡å¤ä»»åŠ¡ç®—æ³•æ­£ç¡®æ€§
- æ™ºèƒ½æé†’åˆ›å»ºå’Œç®¡ç†
- å¼‚å¸¸å¤„ç†å’Œè¾¹ç•Œæ¡ä»¶

**è¦†ç›–ç‡ç›®æ ‡**: 15%

### ç¬¬3å‘¨: æ•°æ®å±‚æµ‹è¯• (2025-11-04 ~ 11-10)

**ç›®æ ‡**: æµ‹è¯•Repositoryå’Œæ•°æ®æŒä¹…åŒ–

**ä¼˜å…ˆæµ‹è¯•æ¨¡å—**:
1. HiveTaskRepository (16ä¸ªæµ‹è¯•)
2. HiveNoteRepository (10ä¸ªæµ‹è¯•)
3. å®ä½“åºåˆ—åŒ–æµ‹è¯•è¡¥å…… (20ä¸ªæµ‹è¯•)

**æµ‹è¯•é‡ç‚¹**:
- CRUDæ“ä½œæ­£ç¡®æ€§
- ç¼“å­˜æ€§èƒ½ä¼˜åŒ–éªŒè¯
- Streamç›‘å¬åŠŸèƒ½
- æ‰¹é‡æ“ä½œäº‹åŠ¡æ€§

**è¦†ç›–ç‡ç›®æ ‡**: 25%

### ç¬¬4å‘¨: Widgetå’ŒUIæµ‹è¯• (2025-11-11 ~ 11-17)

**ç›®æ ‡**: è¡¥å……Widgetæµ‹è¯•

**ä¼˜å…ˆæµ‹è¯•æ¨¡å—**:
1. HomePageå®Œæ•´æµ‹è¯•
2. TaskFormPageè¡¨å•éªŒè¯
3. ListManagementPage CRUD
4. è‡ªå®šä¹‰Widgetç»„ä»¶

**æµ‹è¯•é‡ç‚¹**:
- ç”¨æˆ·äº¤äº’æµç¨‹
- è¡¨å•éªŒè¯é€»è¾‘
- çŠ¶æ€æ›´æ–°æ¸²æŸ“
- å¯¼èˆªæµç¨‹

**è¦†ç›–ç‡ç›®æ ‡**: 35%

### åç»­è¿­ä»£ (ç¬¬5-12å‘¨)

**æ¯2å‘¨ä¸€ä¸ªSprint**:

**Sprint 1 (ç¬¬5-6å‘¨)**:
- äº‘åŒæ­¥æ¨¡å—æµ‹è¯•
- æ¸¸æˆåŒ–æ¨¡å—æµ‹è¯•
- ç»Ÿè®¡åˆ†ææ¨¡å—æµ‹è¯•
- **ç›®æ ‡è¦†ç›–ç‡**: 45%

**Sprint 2 (ç¬¬7-8å‘¨)**:
- é›†æˆæµ‹è¯•æ¡†æ¶æ­å»º
- æ ¸å¿ƒæµç¨‹E2Eæµ‹è¯•
- æ€§èƒ½æµ‹è¯•åŸºå‡†
- **ç›®æ ‡è¦†ç›–ç‡**: 55%

**Sprint 3 (ç¬¬9-10å‘¨)**:
- è¡¥å……è¾¹ç•Œæ¡ä»¶æµ‹è¯•
- å¼‚å¸¸å¤„ç†æµ‹è¯•
- å®‰å…¨æµ‹è¯•
- **ç›®æ ‡è¦†ç›–ç‡**: 65%

**Sprint 4 (ç¬¬11-12å‘¨)**:
- æµ‹è¯•é‡æ„ä¼˜åŒ–
- Goldenæµ‹è¯•
- å‹åŠ›æµ‹è¯•
- **ç›®æ ‡è¦†ç›–ç‡**: 70%

---

## ğŸ“š å…«ã€æµ‹è¯•æœ€ä½³å®è·µ

### 8.1 æµ‹è¯•å‘½åè§„èŒƒ

```dart
// âœ… å¥½çš„å‘½å
test('åˆ›å»ºä»»åŠ¡æ—¶åº”è¯¥ç”Ÿæˆå”¯ä¸€ID')
test('å½“é‡å¤ä»»åŠ¡è¾¾åˆ°æœ€å¤§æ¬¡æ•°æ—¶ä¸åº”ç”Ÿæˆæ–°ä»»åŠ¡')
test('åˆ é™¤ä»»åŠ¡å¤±è´¥æ—¶åº”è¯¥æŠ›å‡ºRepositoryException')

// âŒ ä¸å¥½çš„å‘½å
test('test1')
test('ä»»åŠ¡æµ‹è¯•')
test('testCreateTask')
```

### 8.2 æµ‹è¯•ç»„ç»‡ç»“æ„

```dart
group('TaskService', () {
  late TaskService service;
  // å…±äº«çš„setUp

  setUp(() {
    // åˆå§‹åŒ–
  });

  group('createTask', () {
    test('æ­£å¸¸åœºæ™¯1')
    test('æ­£å¸¸åœºæ™¯2')
  });

  group('updateTask', () {
    test('è¾¹ç•Œæ¡ä»¶1')
    test('å¼‚å¸¸åœºæ™¯1')
  });
});
```

### 8.3 AAAæ¨¡å¼

```dart
test('ç¤ºä¾‹æµ‹è¯•', () {
  // Arrange - å‡†å¤‡
  final input = TaskCreationInput(title: 'æµ‹è¯•');

  // Act - æ‰§è¡Œ
  final result = service.createTask(input);

  // Assert - éªŒè¯
  expect(result.id, isNotEmpty);
});
```

### 8.4 Mockä½¿ç”¨åŸåˆ™

```dart
// âœ… åº”è¯¥Mock
- æ•°æ®åº“æ“ä½œ
- ç½‘ç»œè¯·æ±‚
- æ–‡ä»¶ç³»ç»Ÿ
- æ—¶é—´ç›¸å…³é€»è¾‘
- å¤–éƒ¨æœåŠ¡

// âŒ ä¸åº”è¯¥Mock
- ç®€å•æ•°æ®ç±»
- çº¯å‡½æ•°
- å€¼å¯¹è±¡
```

---

## âš ï¸ ä¹ã€é£é™©è¯„ä¼°

### 9.1 å…³é”®é£é™©

| é£é™© | å½±å“ | æ¦‚ç‡ | ç¼“è§£æªæ–½ |
|------|------|------|---------|
| ç”Ÿäº§Bugå¯¼è‡´æ•°æ®ä¸¢å¤± | æé«˜ | é«˜ | ç«‹å³å®æ–½æ ¸å¿ƒé€»è¾‘æµ‹è¯• |
| äº‘åŒæ­¥å†²çªé€ æˆæ•°æ®æŸå | é«˜ | ä¸­ | ä¼˜å…ˆæµ‹è¯•åŒæ­¥é€»è¾‘ |
| é‡å¤ä»»åŠ¡ç®—æ³•é”™è¯¯ | é«˜ | ä¸­ | å…¨é¢æµ‹è¯•è¾¹ç•Œæ¡ä»¶ |
| æ€§èƒ½é€€åŒ–å¯¼è‡´å¡é¡¿ | ä¸­ | ä¸­ | å»ºç«‹æ€§èƒ½åŸºå‡†æµ‹è¯• |
| æµ‹è¯•ç»´æŠ¤æˆæœ¬è¿‡é«˜ | ä¸­ | ä½ | éµå¾ªæµ‹è¯•æœ€ä½³å®è·µ |

### 9.2 æµ‹è¯•å€ºåŠ¡ç®¡ç†

**é«˜ä¼˜å…ˆçº§** (ç«‹å³å¤„ç†):
1. âœ… ä¿®å¤å¤±è´¥çš„widget_test
2. âœ… TaskServiceæ ¸å¿ƒé€»è¾‘æµ‹è¯•
3. âœ… RecurrenceServiceç®—æ³•æµ‹è¯•

**ä¸­ä¼˜å…ˆçº§** (1ä¸ªæœˆå†…):
1. Widgetæµ‹è¯•è¡¥å…¨
2. Repositoryæ€§èƒ½æµ‹è¯•
3. é›†æˆæµ‹è¯•æ¡†æ¶

**ä½ä¼˜å…ˆçº§** (é•¿æœŸä¼˜åŒ–):
1. Goldenæµ‹è¯•
2. E2Eè‡ªåŠ¨åŒ–
3. è§†è§‰å›å½’æµ‹è¯•

---

## ğŸ¯ åã€è¡ŒåŠ¨è®¡åˆ’æ€»ç»“

### ç«‹å³è¡ŒåŠ¨ (æœ¬å‘¨)

1. âœ… **ä¿®å¤widget_test.dart**
   - æ·»åŠ Hiveåˆå§‹åŒ–
   - æ³¨å†Œæ‰€æœ‰Adapter
   - Mock Providerä¾èµ–

2. âœ… **åˆ›å»ºæµ‹è¯•åŸºç¡€è®¾æ–½**
   - æµ‹è¯•ç›®å½•ç»“æ„
   - æµ‹è¯•è¾…åŠ©å·¥å…·
   - Mockå¯¹è±¡ç”Ÿæˆ

3. âœ… **é…ç½®CI/CD**
   - GitHub Actions
   - è¦†ç›–ç‡æŠ¥å‘Š
   - è´¨é‡é—¨ç¦

4. âœ… **ç¼–å†™ç¬¬ä¸€æ‰¹æµ‹è¯•**
   - TaskService (15ä¸ªæµ‹è¯•)
   - RecurrenceService (18ä¸ªæµ‹è¯•)

### ç¬¬ä¸€ä¸ªæœˆç›®æ ‡

- âœ… 20%æµ‹è¯•è¦†ç›–ç‡
- âœ… 150+æµ‹è¯•ç”¨ä¾‹
- âœ… CI/CDè‡ªåŠ¨åŒ–
- âœ… æµ‹è¯•æ–‡åŒ–å»ºç«‹

### ä¸‰ä¸ªæœˆç›®æ ‡

- âœ… 60%æµ‹è¯•è¦†ç›–ç‡
- âœ… 400+æµ‹è¯•ç”¨ä¾‹
- âœ… å®Œæ•´é›†æˆæµ‹è¯•
- âœ… æ€§èƒ½æµ‹è¯•åŸºå‡†

### æŒç»­æ”¹è¿›

- æ–°åŠŸèƒ½å¿…é¡»TDD
- æ¯å‘¨æµ‹è¯•Review
- å®šæœŸé‡æ„ä¼˜åŒ–
- æµ‹è¯•çŸ¥è¯†åˆ†äº«

---

## ğŸ“ é™„å½•

### A. æ¨èèµ„æº

**å®˜æ–¹æ–‡æ¡£**:
- [Flutter Testing Guide](https://docs.flutter.dev/testing)
- [Mockito Documentation](https://pub.dev/packages/mockito)
- [Riverpod Testing](https://riverpod.dev/docs/essentials/testing)

**ä¹¦ç±**:
- "Test Driven Development" - Kent Beck
- "Growing Object-Oriented Software, Guided by Tests"

### B. æµ‹è¯•æ¸…å•æ¨¡æ¿

è§æµ‹è¯•è¦†ç›–ç‡åˆ†ææŠ¥å‘Šé™„å½•

---

**æŠ¥å‘Šç»“æŸ**

**ç”Ÿæˆæ—¶é—´**: 2025-10-20
**åˆ†æå¸ˆ**: Claude Code - Test Automation Engineer
**ä¸‹æ¬¡æ›´æ–°**: å»ºè®®æ¯2å‘¨æ›´æ–°æµ‹è¯•è¿›åº¦
**è”ç³»æ–¹å¼**: é€šè¿‡é¡¹ç›®Issueè·Ÿè¸ªæµ‹è¯•è¿›åº¦
